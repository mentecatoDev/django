<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>7. Formularios - Django</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "7. Formularios";
    var mkdocs_page_input_path = "7_formularios.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Django</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="../1_introduccion/">1. Introducción</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../2_configuracion_inicial/">2. Configuración Inicial</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../3_hello_world_app/">3. Hello World app</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../4_pages_app/">4. Pages app</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../5_message_board_app/">5. Message Board app</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../6_blog_app/">6. Blog App</a>
	    </li>
          
            <li class="toctree-l1 current">
		
    <a class="current" href="./">7. Formularios</a>
    <ul class="subnav">
            
    <li class="toctree-l2"><a href="#7-formularios">7. Formularios</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#71-formularios">7.1 Formularios</a></li>
        
            <li><a class="toctree-l3" href="#72-actualizar-formularios">7.2 Actualizar Formularios</a></li>
        
            <li><a class="toctree-l3" href="#7-borrar-la-vista">7. Borrar la vista</a></li>
        
            <li><a class="toctree-l3" href="#tests">Tests</a></li>
        
            <li><a class="toctree-l3" href="#7-conclusion">7. Conclusión</a></li>
        
        </ul>
    

    </ul>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Django</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>7. Formularios</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="7-formularios">7. Formularios</h1>
<p>In this chapter we’ll continue working on our blog application from Chapter 5 by
adding forms so a user can create, edit, or delete any of their blog entries.</p>
<h2 id="71-formularios">7.1 Formularios</h2>
<ul>
<li>Los formularios son muy comunes y difíciles de implementar correctamente.</li>
<li>Cada vez que se acepta la entrada de un usuario hay preocupaciones de:<ul>
<li>Seguridad (Ataques XSS)</li>
<li>Se requiere un manejo adecuado de los errores</li>
<li>Hay consideraciones de UI sobre cómo alertar al usuario de problemas con el formulario.</li>
<li>Sin mencionar la necesidad de redireccionarlo en caso de éxito.</li>
</ul>
</li>
<li>
<p>Afortunadamente, los formularios incorporados de Django abstraen gran parte de la dificultad y proporcionan un rico conjunto de herramientas para manejar los casos de uso común que trabajan con los formularios.</p>
</li>
<li>
<p>Actualizar la plantilla base para mostrar un enlace a una página donde introducir nuevas entradas en el blog. Tomará la forma <code>&lt;a href="{% url 'post_new' %}"&gt;&lt;a/&gt;</code> donde <code>post_new</code> es el nombre de la URL.</p>
</li>
</ul>
<p>FICHERO: <code>templates/base.html</code></p>
<pre><code class="html">{% load staticfiles %}
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Django blog&lt;/title&gt;
    &lt;link href=&quot;https://fonts.googleapis.com/css?family=Source+Sans+Pro:400&quot; rel=&quot;stylesheet&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;{% static 'css/base.css' %}&quot;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
      &lt;header&gt;
        &lt;div class=&quot;nav-left&quot;&gt;
          &lt;h1&gt;&lt;a href=&quot;/&quot;&gt;Django blog&lt;/a&gt;&lt;/h1&gt;
        &lt;/div&gt;
        &lt;div class=&quot;nav-right&quot;&gt;
          &lt;a href=&quot;{% url 'post_new' %}&quot;&gt;+ New Blog Post&lt;/a&gt;
        &lt;/div&gt;
      &lt;/header&gt;
      {% block content %}
      {% endblock content %}
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>FICHERO: <code>blog/urls.py</code></p>
<pre><code class="python">from django.urls import path
from . import views


urlpatterns = [
    path('', views.BlogListView.as_view(), name='home'),
    path('post/&lt;int:pk&gt;/', views.BlogDetailView.as_view(), name='post_detail'),
    path('post/new/', views.BlogCreateView.as_view(), name='post_new'),
]
</code></pre>

<ul>
<li>La url empezará con <code>post/new/</code>, la vista se llama <code>BlogCreateView</code>, y la url se llamará <code>post_new</code>.</li>
<li>Crear la vista importando una nueva clase genérica llamada <code>CreateView</code> y luego
heredarla para crear una nueva vista llamada <code>BlogCreateView</code>.</li>
</ul>
<p>FICHERO: <code>blog/views.py</code></p>
<pre><code class="python">from django.views.generic import ListView, DetailView
from django.views.generic.edit import CreateView
from . models import Post


class BlogListView(ListView):
    model = Post
    template_name = 'home.html'


class BlogDetailView(DetailView):
    model = Post
    template_name = 'post_detail.html'


class BlogCreateView(CreateView):
    model = Post
    template_name = 'post_new.html'
    fields = '__all__'
</code></pre>

<ul>
<li>Dentro de <code>BlogCreateView</code> se especifica el modelo de base de datos <code>Post</code>, el nombre de la plantilla <code>post_new.html</code>, y todos los campos con <code>'__all__'</code> ya que sólo hay dos: <code>title</code> y <code>author</code>.</li>
<li>El último paso es crear la plantilla, que llamaremos <code>post_new.html</code>.</li>
</ul>
<pre><code>(blog) $ touch templates/post_new.html
</code></pre>

<p>FICHERO: <code>templates/post_new.html</code></p>
<pre><code>{% extends 'base.html' %}

{% block content %}
    &lt;h1&gt;New post&lt;/h1&gt;
    &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;{% csrf_token %}
      {{ form.as_p }}
      &lt;input type=&quot;submit&quot; value=&quot;Save&quot; /&gt;
    &lt;/form&gt;
{% endblock %}
</code></pre>

<ul>
<li>En la línea superior se hereda la plantilla base.</li>
<li>Se usan etiquetas HTML <code>&lt;form&gt;</code> con el método POST ya que se está enviando datos. Si se reciben datos de un formulario, por ejemplo en un cuadro de búsqueda, se utilizaría GET.</li>
<li>Se añade un <code>{% csrf_token %}</code> que proporciona Django para proteger al formulario de ataques de cross-site scripting. Se debe usar en todos los formularios de Django.</li>
<li>Luego para obtener los datos del formulario se usa <code>{{ form.as_p }}</code> que lo renderiza dentro etiquetas de párrafo <code>&lt;p&gt;</code>.</li>
<li>Por último, se especifica un <code>input type="submit"</code> con el valor "Save".</li>
<li>
<p>Iniciar el servidor con <code>python manage.py runserver</code> e ir a la página web en http://127.0.0.1:8000</p>
</li>
<li>
<p>Hacer clic en el enlace para "+ New Blog Post" que le redirigirá a:
  http://127.0.0.1:8000/post/new/.</p>
</li>
<li>Crear una nueva entrada de blog.</li>
<li>¡Ups! ¿Qué ha pasado?</li>
<li>El mensaje de error de Django se queja de que no se especificó dónde enviar al usuario después de haber enviado el formulario con éxito.</li>
<li>Se enviará al usuario a la página de detalles después de haber tenido éxito; así se podrá ver el mensaje completo.</li>
<li>Se puede seguir la sugerencia de Django y añadir un <code>get_absolute_url</code> al modelo. Esta es una buena práctica que siempre se debe hacer. Establece una URL canónica para un objeto, de modo que aunque la estructura de las URL cambie en el futuro, la referencia al objeto específico es la misma.</li>
<li>En resumen, se debería añadir un método <code>get_absolute_url()</code> y <code>__str__()</code> a cada modelo que se escriba.</li>
</ul>
<p>FICHERO: <code>blog/models.py</code></p>
<pre><code>    from django.db import models
ç   from django.urls import reverse


    class Post(models.Model):
        title = models.CharField(max_length=200)
        author = models.ForeignKey(
            'auth.User',
            on_delete=models.CASCADE,
        )
        body = models.TextField()

        def __str__(self):
            return self.title

        def get_absolute_url(self):
            return reverse('post_detail', args=[str(self.id)])
</code></pre>

<ul>
<li><code>reverse</code> es una función muy útil que Django proporciona para referir a un objeto por el nombre de plantilla URL, en este caso <code>post_detail</code>.</li>
</ul>
<pre><code>path('post/&lt;int:pk&gt;/', views.BlogDetailView.as_view(), name='post_detail'),
</code></pre>

<ul>
<li>Eso significa que para que esta ruta funcione debemos pasar también como argumento la <code>pk</code> o clave primaria del objeto. A pesar de que <code>pk</code> e <code>id</code> son intercambiables en Django, la documentación de Django recomienda usar <code>self.id</code> con <code>get_absolute_url</code>.</li>
<li>Así le decimos a Django que la última ubicación de una entrada de un Post es su vista <code>post_detail</code> que es <code>posts/&lt;int:pk&gt;/</code> por lo que la ruta para la primera entrada que hemos hecho estará en <code>posts/1</code>.</li>
<li>Intentar crear una nueva entrada en el blog de nuevo en http://127.0.0.1:8000/post/new/ y se tendrá éxito al ser redirigido a la página de vista detallada donde aparece el post.</li>
<li>También se notará que la entrada anterior en el blog también está ahí. Fue enviada con éxito a la base de datos pero Django no supo cómo redirigirse después de eso.</li>
<li>Aunque se podría entrar en el administrador de Django para borrar los mensajes no deseados, es mejor añadir formularios para que un usuario pueda actualizar y eliminar los mensajes existentes directamente desde el sitio.</li>
</ul>
<h2 id="72-actualizar-formularios">7.2 Actualizar Formularios</h2>
<ul>
<li>Para empezar, se añade un nuevo enlace a <code>post_detail.html</code> para que la opción de editar una entrada de blog aparezca en una página de blog individual.</li>
</ul>
<p>FICHERO: <code>templates/post_detail.html</code></p>
<pre><code class="html">{% extends 'base.html' %}

{% block content %}
  &lt;div class=&quot;post-entry&quot;&gt;
    &lt;h2&gt;{{ object.title }}&lt;/h2&gt;
    &lt;p&gt;{{ object.body }}&lt;/p&gt;
  &lt;/div&gt;

  &lt;a href=&quot;{% url 'post_edit' post.pk %}&quot;&gt;+ Edit Blog Post&lt;/a&gt;
{% endblock content %}
</code></pre>

<ul>
<li>Se ha  añadido un enlace usando <code>&lt;a href&gt;...&lt;/a&gt;</code> y la etiqueta del motor de plantillas de Django <code>{% url... %}</code>. Dentro de ella se ha especificado el nombre del objetivo de la url, que se llamará <code>post_edit</code>, y también se ha pasado el parámetro necesario, que es la clave principal del post <code>post.pk</code>.</li>
<li>A continuación se crea la plantilla para la página de edición llamada <code>post_edit.html</code>.</li>
</ul>
<pre><code class="bash">(blog) $ touch templates/post_edit.html
</code></pre>

<p>FICHERO: <code>templates/post_edit.html</code></p>
<pre><code class="python">{% extends 'base.html' %}

{% block content %}
  &lt;h1&gt;Edit post&lt;/h1&gt;
  &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;{% csrf_token %}
    {{ form.as_p }}
    &lt;input type=&quot;submit&quot; value=&quot;Update&quot; /&gt;
  &lt;/form&gt;
{% endblock %}
</code></pre>

<ul>
<li>De nuevo se usan las etiquetas HTML <code>&lt;form&gt;&lt;/form&gt;</code>, el <code>csrf_token</code> de Django por seguridad, el <code>form.as_p</code> para mostrar los campos de formulario con etiquetas de párrafo, y finalmente se le da el valor "Update" en el botón <em>submit</em>.</li>
<li>Ahora a nuestra vista. Necesitamos importar UpdateView en la segunda línea superior y luego subclasificarla en nuestra nueva vista BlogUpdateView .
FICHERO: <code>blog/views.py</code></li>
</ul>
<pre><code class="python">from django.views.generic import ListView, DetailView
from django.views.generic.edit import CreateView, UpdateView
from . models import Post


class BlogListView(ListView):
    model = Post
    template_name = 'home.html'

class BlogDetailView(DetailView):
    model = Post
    template_name = 'post_detail.html'


class BlogCreateView(CreateView):
    model = Post
    template_name = 'post_new.html'
    fields = '__all__'


class BlogUpdateView(UpdateView):
    model = Post
    fields = ['title', 'body']
    template_name = 'post_edit.html'
</code></pre>

<ul>
<li>Nótese que en <code>BlogUpdateView</code> se listan explícitamente los campos que se quieren usar <code>['title', 'body']</code> en lugar de usar <code>'__all__'</code>. Esto se debe a que se asume que el autor del post no cambia; sólo se quiere que el título y el texto sean editables.</li>
<li>El último paso es actualizar el archivo <code>urls.py</code> de la siguiente manera:</li>
</ul>
<p>FICHERO: <code>blog/urls.py</code></p>
<pre><code class="python">from django.urls import path
from . import views


urlpatterns = [
    path('', views.BlogListView.as_view(), name='home'),
    path('post/&lt;int:pk&gt;/', views.BlogDetailView.as_view(), name='post_detail'),
    path('post/new/', views.BlogCreateView.as_view(), name='post_new'),
    path('post/&lt;int:pk&gt;/edit/',views.BlogUpdateView.as_view(), name='post_edit'),
]
</code></pre>

<ul>
<li>En la parte superior se agrega la vista <code>BlogUpdateView</code> a la lista de vistas importadas, luego se creará un nuevo patrón de url para <code>/post/pk/edit</code> y se le dará el nombre <code>post_edit</code>.</li>
<li>Ahora, si se hace click en una entrada del blog, se verá el nuevo botón <em>Editar</em>.</li>
<li>Si se hace clic en <em>"+ Edit Blog Post"</em> se redirigirá a http://127.0.0.1:8000/post/1/edit/
si esa es la primera entrada en el blog.</li>
<li>Tengase en cuenta que el formulario está precargado con los datos existentes en la base de datos para el post.</li>
<li>Vamos a hacer un cambio...</li>
</ul>
<p>-Y después de pulsar el botón "Update" somos redirigidos a la vista de detalles del <em>post</em> en el que se puede ver el cambio. Esto se debe a la configuración <code>get_absolute_url</code>.
- Si se navega a la página principal se podrás ver el cambio junto a todas las demás entradas.</p>
<h2 id="7-borrar-la-vista">7. Borrar la vista</h2>
<ul>
<li>El proceso de creación de un formulario para borrar entradas del blog es muy similar al de la actualización de un post.</li>
<li>Se usará otra vista genérica basada en clases, <code>DeleteView</code>, y se necesita crear una vista, una url y una plantilla para la funcionalidad.</li>
<li>Se comenzará por agregar un enlace para eliminar los post del blog en la página de blog individual, <code>post_detail.html</code>.</li>
</ul>
<p>FICHERO: <code>templates/post_detail.html</code></p>
<pre><code class="python">{% extends 'base.html' %}

{% block content %}
  &lt;div class=&quot;post-entry&quot;&gt;
    &lt;h2&gt;{{ object.title }}&lt;/h2&gt;
    &lt;p&gt;{{ object.body }}&lt;/p&gt;
  &lt;/div&gt;

  &lt;p&gt;&lt;a href=&quot;{% url 'post_edit' post.pk %}&quot;&gt;+ Edit Blog Post&lt;/a&gt;&lt;/p&gt;
  &lt;p&gt;&lt;a href=&quot;{% url 'post_delete' post.pk %}&quot;&gt;+ Delete Blog Post&lt;/a&gt;&lt;/p&gt;
{% endblock content %}
</code></pre>

<ul>
<li>A continuación, se crea un nuevo archivo para la plantilla de la página de borrado.</li>
</ul>
<pre><code class="bash">(blog) $ touch templates/post_delete.html
</code></pre>

<p>FICHERO: <code>templates/post_delete.html</code></p>
<pre><code>{% extends 'base.html' %}

{% block content %}
  &lt;h1&gt;Delete post&lt;/h1&gt;
  &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;{% csrf_token %}
    &lt;p&gt;Are you sure you want to delete &quot;{{ post.title }}&quot;?&lt;/p&gt;
    &lt;input type=&quot;submit&quot; value=&quot;Confirm&quot; /&gt;
  &lt;/form&gt;
{% endblock %}
</code></pre>

<blockquote>
<p>Nota: se usa <code>post.title</code> para mostrar el título de la entrada en el blog. También se podría usar <code>object.title</code> ya que también lo proporciona <code>DetailView</code>.
- Ahora se actualiza el archivo <code>views.py</code>, importando <code>DeleteView</code> y <code>reverse_lazy</code> en la parte superior, y luego creamos una nueva vista que hereda de <code>DeleteView</code>.</p>
</blockquote>
<p>FICHERO: <code>blog/views.py</code></p>
<pre><code class="python">from django.views.generic import ListView, DetailView
from django.views.generic.edit import CreateView, UpdateView, DeleteView
from django.urls import reverse_lazy
from . models import Post


class BlogListView(ListView):
    model = PostChapter
    template_name = 'home.html'


class BlogDetailView(DetailView):
    model = Post
    template_name = 'post_detail.html'


class BlogCreateView(CreateView):
    model = Post
    template_name = 'post_new.html'
    fields = '__all__'


class BlogUpdateView(UpdateView):
    model = Post
    fields = ['title', 'body']
    template_name = 'post_edit.html'


class BlogDeleteView(DeleteView):
    model = Post
    template_name = 'post_delete.html'
    success_url = reverse_lazy('home')
</code></pre>

<ul>
<li>Se usa <code>reverse_lazy</code> en vez de sólo <code>reverse</code> para que no ejecute la redirección URL
hasta que la vista haya terminado de borrar la entrada del blog.</li>
<li>Finalmente agregar una url importando la vista <code>BlogDeleteView</code> y agregando un nuevo patrón:</li>
</ul>
<p>FICHERO: <code>blog/urls.py</code></p>
<pre><code class="python">from django.urls import path
from . import views
urlpatterns = [
path('', views.BlogListView.as_view(), name='home'),
path('post/&lt;int:pk&gt;/', views.BlogDetailView.as_view(), name='post_detail'),
path('post/new/', views.BlogCreateView.as_view(), name='post_new'),
path('post/&lt;int:pk&gt;/edit/',
views.BlogUpdateView.as_view(), name='post_edit'),
path('post/&lt;int:pk&gt;/delete/',
views.BlogDeleteView.as_view(), name='post_delete'),
]
</code></pre>

<h2 id="tests">Tests</h2>
<ul>
<li>Se ha añadido un método <code>get_absolute_url</code> al modelo y nuevas vistas para crear, actualizar y editar entradas. Eso significa que se necesitan cuatro nuevas pruebas:</li>
<li>def test_get_absolute_url</li>
<li>def test_post_create_view</li>
<li>def test_post_update_view</li>
<li>def test_post_delete_view</li>
</ul>
<p>FICHERO: <code>blog/tests.py</code></p>
<pre><code class="python">from django.contrib.auth import get_user_model
from django.test import Client, TestCase
from django.urls import reverse
from .models import Post


class BlogTests(TestCase):


    def setUp(self):
        self.user = get_user_model().objects.create_user(
            username='testuser',
            email='test@email.com',
            password='secret'
        )

        self.post = Post.objects.create(
            title='A good title',
            body='Nice body content',
            author=self.user,
        )

    def test_string_representation(self):
        post = Post(title='A sample title')
        self.assertEqual(str(post), post.title)

    def test_get_absolute_url(self):
        self.assertEquals(self.post.get_absolute_url(), '/post/1/')

    def test_post_content(self):
        self.assertEqual(f'{self.post.title}', 'A good title')
        self.assertEqual(f'{self.post.author}', 'testuser')
        self.assertEqual(f'{self.post.body}', 'Nice body content')

    def test_post_list_view(self):
        response = self.client.get(reverse('home'))
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, 'Nice body content')
        self.assertTemplateUsed(response, 'home.html')

    def test_post_detail_view(self):
        response = self.client.get('/post/1/')
        no_response = self.client.get('/post/100000/')
        self.assertEqual(response.status_code, 200)
        self.assertEqual(no_response.status_code, 404)
        self.assertContains(response, 'A good title')
        self.assertTemplateUsed(response, 'post_detail.html')

    def test_post_create_view(self):
        response = self.client.post(reverse('post_new'), {
            'title': 'New title',
            'body': 'New text',
            'author': self.user,
        })
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, 'New title')
        self.assertContains(response, 'New text')

    def test_post_update_view(self):
        response = self.client.post(reverse('post_edit', args='1'), {
            'title': 'Updated title',
            'body': 'Updated text',
        })
        self.assertEqual(response.status_code, 302)

    def test_post_delete_view(self):
        response = self.client.get(reverse('post_delete', args='1'))
        self.assertEqual(response.status_code, 200)
</code></pre>

<ul>
<li>Se espera que la url de la prueba esté en <code>post/1/</code> ya que sólo hay un post y el <code>1</code> es la clave primaria que Django añade automáticamente. Para testar la creación de la vista se crea una nueva respuesta y luego se asegura que se pase la respuesta (código de estado 200) y contenga nuestro el título y texto del cuerpo.</li>
<li>Para actualizar la vista, se accede al primer post que tiene un <code>pk</code> de <code>1</code> que se pasa como único argumento y confirmamos que resulta en una redirección 302.</li>
<li>Finalmente se prueba la vista de borrado confirmando que si eliminamos un post el código de estado es 200 para que sea exitoso.</li>
<li>Siempre hay más pruebas que pueden ser añadidas, pero esto al menos da cobertura a todas las nuevas funcionalidades.</li>
</ul>
<h2 id="7-conclusion">7. Conclusión</h2>
<ul>
<li>En una pequeña cantidad de código se ha construido una aplicación de blog que permite crear, leer, actualizar y borrar entradas de blog. Esta funcionalidad básica se conoce por el acrónimo CRUD: Create-Read-Update-Delete. Aunque hay múltiples maneras de lograr esta misma funcionalidad -se podría haber usado vistas basadas en funciones o haber escrito unas vistas propias basadas en clases- se ha demostrado lo poco de código que se necesita en Django para que esto suceda.</li>
</ul>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="../6_blog_app/" class="btn btn-neutral" title="6. Blog App"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../6_blog_app/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>

</body>
</html>
