<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>13. Email - Django</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "13. Email";
    var mkdocs_page_input_path = "13_email.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Django</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="../por_que_django/">¿Por qué Django?</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../01_introduccion/">1. Introducción</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../02_configuracion_inicial/">2. Configuración Inicial</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../03_hello_world_app/">3. Hello World app</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../04_pages_app/">4. Pages app</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../05_message_board_app/">5. Message Board app</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../06_blog_app/">6. Blog app</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../07_formularios/">7. Formularios</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../08_cuentas_de_usuarios/">8. Cuentas de Usuarios</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../09_modelo_de_usuario_personalizado/">9. Modelo de Usuario Personalizado</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../10_autenticacion_de_usuarios/">10. Autenticación de Usuarios</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../11_bootstrap/">11. Bootstrap</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../12_cambio_y_restauracion_de_contrasenas/">12. Cambio y Restauración de Contraseñas</a>
	    </li>
          
            <li class="toctree-l1 current">
		
    <a class="current" href="./">13. Email</a>
    <ul class="subnav">
            
    <li class="toctree-l2"><a href="#13-correo-electronico">13. Correo electrónico</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#131-sendgrid">13.1. SendGrid</a></li>
        
            <li><a class="toctree-l3" href="#132-correos-electronicos-personalizados">13.2. Correos electrónicos personalizados</a></li>
        
            <li><a class="toctree-l3" href="#133-conclusion">13.3. Conclusión</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#documentacion-django">Documentación Django</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#envio-de-emails">Envío de emails</a></li>
        
            <li><a class="toctree-l3" href="#ejemplo-rapido">Ejemplo rápido</a></li>
        
            <li><a class="toctree-l3" href="#send_mail">send_mail()</a></li>
        
            <li><a class="toctree-l3" href="#send_mass_mail">send_mass_mail()</a></li>
        
            <li><a class="toctree-l3" href="#send_mass_mail-vs-send_mail">send_mass_mail() vs. send_mail()</a></li>
        
            <li><a class="toctree-l3" href="#mail_admins">mail_admins()</a></li>
        
            <li><a class="toctree-l3" href="#mail_managers">mail_managers()</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#manually-open-the-connection">Manually open the connection</a></li>
    

    <li class="toctree-l2"><a href="#construct-an-email-message-that-uses-the-connection">Construct an email message that uses the connection</a></li>
    

    <li class="toctree-l2"><a href="#construct-two-more-messages">Construct two more messages</a></li>
    

    <li class="toctree-l2"><a href="#send-the-two-emails-in-a-single-call-">Send the two emails in a single call -</a></li>
    

    <li class="toctree-l2"><a href="#the-connection-was-already-open-so-send_messages-doesnt-close-it">The connection was already open so send_messages() doesn't close it.</a></li>
    

    <li class="toctree-l2"><a href="#we-need-to-manually-close-the-connection">We need to manually close the connection.</a></li>
    

    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../14_newspaper_app/">14. Newspaper app</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../15_permisos_y_autorizacion/">15. Permisos y Autorización</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../16_comentarios/">16. Comentarios</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Django</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>13. Email</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="13-correo-electronico">13. Correo electrónico</h1>
<p>Ahora se quiere que los correos electrónicos se envíen realmente a los usuarios, no sólo a la consola de línea de comandos.</p>
<p>Se precisa de una <em>SendGrid</em> y actualizar los archivos <code>settings.py</code>. Django se encargará del resto.</p>
<h2 id="131-sendgrid">13.1. SendGrid</h2>
<p><a href="https://sendgrid.com/"><em>SendGrid</em></a> es un servicio popular para el envío de e-mails transaccionales. A Django no le importa el servicio que se elija; se puede usar también <a href="https://www.mailgun.com/"><em>MailGun</em></a> o cualquier otro servicio con la misma facilidad.</p>
<ul>
<li>En la página de inicio de <em>SendGrid</em>, hacer clic en "<a href="https://signup.sendgrid.com/">Start for Free</a>".</li>
<li>Registrarse para obtener su cuenta gratuita en la siguiente página.</li>
<li>Asegurarse de que la cuenta de correo electrónico que se utiliza para <em>SendGrid</em> <strong>no sea la misma cuenta de correo electrónico que se tiene para la cuenta de superusuario</strong> en el proyecto de Newspaper o pueden suceder errores extraños.</li>
<li>Luego de confirmar la nueva cuenta a través de un correo electrónico, se pedirá que se ingrese y nos llevará a la página del panel de control de <em>SendGrid</em>.</li>
<li>Ahora podemos configurar el código Django en el archivo <code>settings.py</code>. Primero se actualizará el backend de correo electrónico para usar SMTP.</li>
</ul>
<p>FICHERO: <code>newspaper_project/settings.py</code></p>
<pre><code class="python">EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
</code></pre>

<ul>
<li>Luego, justo debajo, agregar las siguientes cinco líneas de configuración de correo electrónico. Tener en cuenta que lo ideal sería almacenar información segura como la contraseña en variables de entorno, pero no estamos aquí para mantener las cosas simples.</li>
</ul>
<p>FICHERO: <code>newspaper_project/settings.py</code></p>
<pre><code class="python">EMAIL_HOST = 'smtp.sendgrid.net'
EMAIL_HOST_USER = 'sendgrid_username'
EMAIL_HOST_PASSWORD = 'sendgrid_password'
EMAIL_PORT = 587
EMAIL_USE_TLS = True
</code></pre>

<ul>
<li>Asegúrarse de usar el nombre de usuario SendGrid para EMAIL_HOST_USER y
la contraseña de EMAIL_HOST_PASSWORD.</li>
<li>Eso es todo.</li>
</ul>
<h2 id="132-correos-electronicos-personalizados">13.2. Correos electrónicos personalizados</h2>
<ul>
<li>Utilizar la barra de búsqueda de Github e introducir algunas palabras del texto del correo electrónico. Si se escribe "You're receiving this email because" se terminará en una página muy concreta de Github.</li>
<li>El primer resultado es el que se desea. Muestra que el código se encuentra en <code>django/contrib/admin/templates/registration/password_reset_email.html</code>. Eso significa que en la app <code>contrib</code> el archivo que queremos se llama <code>password_reset_email.html</code>.</li>
</ul>
<p>Aquí está el texto por defecto del código fuente de Django.</p>
<pre><code class="text">{% load i18n %}{% autoescape off %}
{% blocktrans %}You're receiving this email because you requested a password reset for your user account at {{ site_name }}.{% endblocktrans %}

{% trans &quot;Please go to the following page and choose a new password:&quot; %}
{% block reset_link %}
{{ protocol }}://{{ domain }}{% url 'password_reset_confirm' uidb64=uid token=token %}
{% endblock %}
{% trans &quot;Your username, in case you've forgotten:&quot; %} {{ user.get_username }}

{% trans &quot;Thanks for using our site!&quot; %}

{% blocktrans %}The {{ site_name }} team{% endblocktrans %}

{% endautoescape %}
</code></pre>

<ul>
<li>Para cambiarlo, se necesita crear un nuevo archivo <code>password_reset_email.html</code> en la carpeta <code>registration</code>.</li>
</ul>
<pre><code class="bash">(news) $ touch templates/registration/password_reset_email.html
</code></pre>

<ul>
<li>Usar el siguiente código que ajusta lo que Django proporcionó por defecto.</li>
</ul>
<p>FICHERO: <code>templates/registration/password_reset_email.html</code></p>
<pre><code class="text">{% load i18n %}{% autoescape off %}
{% trans &quot;Hi&quot; %} {{ user.get_username }},

{% trans &quot;We've received a request to reset your password. If you didn't make this request, you can safely ignore this email. Otherwise, click the button below to reset your password.&quot; %}

{% block reset_link %}
{{ protocol }}://{{ domain }}{% url 'password_reset_confirm' uidb64=uid token=token %}
{% endblock %}
{% endautoescape %}
</code></pre>

<ul>
<li>Arriba se carga la etiqueta de la plantilla i18n lo que significa que este texto puede ser traducido a varios idiomas. Django tiene un sólido soporte de internacionalización aunque cubrirlo está fuera de nuestro alcance, por ahora.</li>
<li>Se saluda al usuario por su nombre gracias a <code>user.get_username</code>. Luego se usa el bloque <code>reset_link</code> incorporado para incluir el enlace URL personalizado.</li>
<li>También se actualiza el título del asunto del correo electrónico. Para ello, se crea un nuevo archivo <code>templates/registration/password_reset_subject.txt</code>.</li>
</ul>
<pre><code class="bash">(news) $ touch templates/registration/password_reset_subject.txt
</code></pre>

<ul>
<li>Luego agregar la siguiente línea de código al archivo <code>password_reset_subject.txt</code>.</li>
</ul>
<pre><code class="text">Please reset your password
</code></pre>

<h2 id="133-conclusion">13.3. Conclusión</h2>
<p>Se ha terminado de implementar un flujo de autenticación de usuario completo. Los usuarios pueden ingresar una nueva cuenta, iniciar sesión, cerrar sesión, cambiar contraseña y restablecerla.</p>
<h1 id="documentacion-django">Documentación Django</h1>
<h2 id="envio-de-emails"><a href="https://docs.djangoproject.com/es/3.0/topics/email/#module-django.core.mail">Envío de emails</a></h2>
<p>Aunque Python proporciona una interfaz de envío de correo a través del módulo <a href="https://docs.python.org/3/library/smtplib.html#module-smtplib"><code>smtplib</code></a>, Django proporciona un par de <em>wrappers</em> ligeros que lo recubren. Estos <em>wrappers</em> se proporcionan para hacer el envío de correo electrónico de forma extra rápida, para ayudar a probar el envío de correo electrónico durante el desarrollo y para proporcionar apoyo a las plataformas que no pueden utilizar SMTP.</p>
<p>El código vive en el módulo <code>django.core.mail</code>.</p>
<h2 id="ejemplo-rapido"><a href="https://docs.djangoproject.com/es/3.0/topics/email/#quick-example">Ejemplo rápido</a></h2>
<p>En dos líneas:</p>
<pre><code>from django.core.mail import send_mail

send_mail(
    'Subject here',
    'Here is the message.',
    'from@example.com',
    ['to@example.com'],
    fail_silently=False,
)
</code></pre>

<p>El correo se envía usando el host SMTP y el puerto especificado en los ajustes <a href="https://docs.djangoproject.com/es/3.0/ref/settings/#std:setting-EMAIL_HOST"><code>EMAIL_HOST</code></a> y <a href="https://docs.djangoproject.com/es/3.0/ref/settings/#std:setting-EMAIL_PORT"><code>EMAIL_PORT</code></a>. Los ajustes <a href="https://docs.djangoproject.com/es/3.0/ref/settings/#std:setting-EMAIL_HOST_USER"><code>EMAIL_HOST_USER</code></a> y <a href="https://docs.djangoproject.com/es/3.0/ref/settings/#std:setting-EMAIL_HOST_PASSWORD"><code>EMAIL_HOST_PASSWORD</code></a>, si están configurados, se utilizan para autenticarse en el servidor SMTP, y los ajustes <a href="https://docs.djangoproject.com/es/3.0/ref/settings/#std:setting-EMAIL_USE_TLS"><code>EMAIL_USE_TLS</code></a> y <a href="https://docs.djangoproject.com/es/3.0/ref/settings/#std:setting-EMAIL_USE_SSL"><code>EMAIL_USE_SSL</code></a> controlan si se utiliza una conexión segura.</p>
<blockquote>
<p>Nota
El conjunto de caracteres del correo electrónico enviado con <code>django.core.mail</code> se ajustará al valor ajustado en <a href="https://docs.djangoproject.com/es/3.0/ref/settings/#std:setting-DEFAULT_CHARSET"><code>DEFAULT_CHARSET</code></a>.</p>
</blockquote>
<h2 id="send_mail"><a href="https://docs.djangoproject.com/es/3.0/topics/email/#send-mail"><code>send_mail()</code></a></h2>
<pre><code class="python">send_mail`(subject, message, from_email, recipient_list, fail_silently=False, auth_user=None, auth_password=None, connection=None, html_message=None
</code></pre>

<p>En la mayoría de los casos, se puede enviar un correo electrónico usando <code>django.core.mail.send_mail()</code>.</p>
<p>Se requieren los parámetros "subject", "message", "from_email" y "recipient_list".</p>
<ul>
<li><code>subject</code>: Una cadena.</li>
<li><code>message</code>: Una cadena.</li>
<li><code>from_email</code>: Una cadena.</li>
<li><code>recipient_list</code>: Una lista de cadenas, cada una con una dirección de correo electrónico. Cada miembro de <em>la lista de recipientes</em> verá a los demás destinatarios en el campo "From:" del mensaje de correo electrónico.</li>
<li><code>fail_silently</code>: Un booleano. Cuando es <code>False</code>, <code>send_mail()</code> levantará una <a href="https://docs.python.org/3/library/smtplib.html#smtplib.SMTPException"><code>smtplib.SMTPException</code></a> si ocurre un error. Consultar los documentos de <a href="https://docs.python.org/3/library/smtplib.html#module-smtplib"><code>smtplib</code></a> para ver una lista de posibles excepciones, todas ellas subclases de <a href="https://docs.python.org/3/library/smtplib.html#smtplib.SMTPException"><code>SMTPException</code></a>.</li>
<li><code>auth_user</code>: El nombre de usuario opcional a usar para autenticarse en el servidor SMTP. Si no se proporciona, Django usará el valor del parámetro <a href="https://docs.djangoproject.com/es/3.0/ref/settings/#std:setting-EMAIL_HOST_USER"><code>EMAIL_HOST_USER</code></a>.</li>
<li><code>auth_password</code>: La contraseña opcional a utilizar para autenticarse en el servidor SMTP. Si no se proporciona, Django utilizará el valor del parámetro <a href="https://docs.djangoproject.com/es/3.0/ref/settings/#std:setting-EMAIL_HOST_PASSWORD"><code>EMAIL_HOST_PASSWORD</code></a>.</li>
<li><code>connection</code>: El backend opcional de correo electrónico a utilizar para enviar el correo. Si no se especifica, se usará una instancia del backend por defecto. Ver la documentación en <a href="https://docs.djangoproject.com/es/3.0/topics/email/#topic-email-backends">Email backends</a> para más detalles.</li>
<li><code>html_message</code>: Si se proporciona <code>html_message</code>, el correo electrónico resultante será un correo electrónico <em>multiparte/alternativo</em> con <code>message</code> como tipo de contenido <em>texto/plano</em> y <code>html_message</code> como tipo de contenido <em>texto/html</em>.</li>
</ul>
<p>El valor de retorno será el número de mensajes entregados con éxito (que puede ser <code>0</code> o <code>1</code> ya que sólo se puede enviar un mensaje).</p>
<h2 id="send_mass_mail">send_mass_mail()</h2>
<pre><code class="python">send_mass_mail(datatuple, fail_silently=False, auth_user=None, auth_password=None, connection=None)
</code></pre>

<p><code>django.core.mail.send_mass_mail()</code> está pensado para manejar el envío masivo de correo electrónico.</p>
<p><code>datatuple</code> es una tupla en la que cada elemento está en este formato:
```￼
(subject, message, from_email, recipient_list)</p>
<pre><code>`fail_silently`, `auth_user` y `auth_password` tienen las mismas funciones que en `send_mail()`.

Cada elemento separado del `datatuple` resulta en un mensaje de correo electrónico separado. Al igual que en `send_mail()`, los destinatarios de la misma lista de destinatarios verán todas las demás direcciones en el campo &quot;To:&quot; de los mensajes de correo electrónico.

Por ejemplo, el siguiente código enviaría dos mensajes diferentes a dos conjuntos de destinatarios diferentes; sin embargo, sólo se abriría una conexión con el servidor de correo:

```python
mensaje1 = ('Subject here', 'Here is the message', 'from@example.com', ['first@example.com', 'other@example.com'])
message2 = ('Another Subject', 'Here is another message', 'from@example.com', ['second@test.com'])
send_mass_mail((mensaje1, mensaje2), fail_silently=False)
</code></pre>

<p>El valor de retorno será el número de mensajes entregados con éxito.</p>
<h2 id="send_mass_mail-vs-send_mail"><code>send_mass_mail()</code> vs. <code>send_mail()</code></h2>
<p>La principal diferencia entre <code>send_mass_mail()</code> y <code>send_mail()</code> es que <code>send_mail()</code> abre una conexión al servidor de correo cada vez que se ejecuta, mientras que send_mass_mail() utiliza una única conexión para todos sus mensajes. Esto hace que <code>send_mass_mail()</code> sea ligeramente más eficiente.</p>
<pre><code class="python">mail_admins()
mail_admins(subject, message, fail_silently=Falso, connection=None, html_message=None)
</code></pre>

<h2 id="mail_admins"><code>mail_admins()</code></h2>
<pre><code>mail_admins`(*subject*, *message*, *fail_silently=False*, *connection=None*, *html_message=None*)
</code></pre>

<p><code>django.core.mail.mail_admins()</code> es un atajo para enviar un correo electrónico a los administradores del sitio, como se define en la configuración de ADMINS.</p>
<p><code>mail_admins()</code> antepone al asunto el valor del ajuste <code>EMAIL_SUBJECT_PREFIX</code>, que es <code>[Django]</code>  por defecto.</p>
<p>El encabezado "From:" del correo electrónico será el valor del ajuste <code>SERVER_EMAIL</code>.</p>
<p>Este método existe por conveniencia y legibilidad.</p>
<p>Si se proporciona <code>html_message</code>, el correo electrónico resultante será un correo electrónico multiparte/alternativo con el mensaje de tipo text/plain y <code>html_message</code> de tipo text/html.</p>
<h2 id="mail_managers">mail_managers()</h2>
<pre><code>mail_managers(subject, message, fail_silently=Falso, connection=None, html_message=None)
</code></pre>

<p><code>django.core.mail.mail_managers()</code> es igual que <code>mail_admins()</code>, excepto que envía un correo electrónico a los administradores del sitio, como se define en la configuración <code>MANAGERS</code>.</p>
<h3 id="ejemplos">Ejemplos</h3>
<p>Esto envía un solo correo electrónico a john@example.com y jane@example.com, y ambos aparecen en el "Para:'':</p>
<pre><code class="python">send_mail(
    &quot;Sujeto&quot;,
    &quot;Mensaje&quot;,
    'from@example.com',
    ['john@example.com', 'jane@example.com'],
)
</code></pre>

<p>Esto envía un mensaje a john@example.com y jane@example.com, y ambos reciben un correo electrónico separado:</p>
<p>￼```python
datatuple = (('Asunto', 'Mensaje', 'from@example.com', ['john@example.com']),
('Asunto', 'Mensaje', 'from@example.com', ['jane@example.com']),)
send_mass_mail(datatuple)</p>
<pre><code>
Prevenir la inyección en la cabeza...
La inyección de cabeceras es un exploit de seguridad en el que un atacante inserta cabeceras de correo electrónico adicionales para controlar el &quot;Para:&quot; y &quot;Desde:&quot; en los mensajes de correo electrónico que sus scripts generan.

Las funciones de correo electrónico de Django descritas anteriormente protegen contra la inyección de encabezado prohibiendo las nuevas líneas en los valores de los encabezados. Si algún asunto, from_email o recipient_list contiene una nueva línea (ya sea en estilo Unix, Windows o Mac), la función de correo electrónico (p. ej., send_mail()) elevará django.core.mail.BadHeaderError (una subclase de ValueError) y, por lo tanto, no enviará el correo electrónico. Es tu responsabilidad validar todos los datos antes de pasarlos a las funciones de correo electrónico.

Si un mensaje contiene cabeceras al principio de la cadena, las cabeceras se imprimirán como el primer bit del mensaje de correo electrónico.

Aquí hay una vista de ejemplo que toma un asunto, mensaje y from_email de los datos POST de la solicitud, lo envía a admin@example.com y lo redirige a &quot;/contacto/gracias/&quot; cuando está hecho:

￼
desde django.core.mail importar BadHeaderError, send_mail
de django.http import HttpResponse, HttpResponseRedirect

def send_email(request):
    subject = request.POST.get('subject', '')
    mensaje = request.POST.get('mensaje', '')
    from_email = request.POST.get('from_email', '')
    si el asunto y el mensaje y from_email:
        Inténtalo:
            send_mail(subject, message, from_email, ['admin@example.com'])
        excepto BadHeaderError:
            devuelve HttpResponse('Cabecera inválida encontrada').
        return HttpResponseRedirect('/contacto/gracias/')
    ...sino..:
        # En realidad usaríamos una clase de forma
        # para obtener los errores de validación adecuados.
        devuelve HttpResponse('Asegúrate de que todos los campos están introducidos y son válidos')
La clase EmailMessage¶
Las funciones send_mail() y send_mass_mail() de Django son en realidad envoltorios delgados que hacen uso de la clase EmailMessage.

No todas las características de la clase EmailMessage están disponibles a través de las funciones send_mail() y las funciones de envoltura relacionadas. Si desea utilizar funciones avanzadas, como destinatarios CCO, archivos adjuntos o correo electrónico de varias partes, deberá crear instancias de EmailMessage directamente.

Nota

Esto es...`nd_mass_mail()`[¶](https://docs.djangoproject.com/es/3.0/topics/email/#send-mass-mail)

- `send_mass_mail`(*datatuple*, *fail_silently=False*, *auth_user=None*, *auth_password=None*, *connection=None*)[[fuente\]](https://docs.djangoproject.com/es/3.0/_modules/django/core/mail/#send_mass_mail)[¶](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.send_mass_mail)



`django.core.mail.send_mass_mail()` is intended to handle mass emailing.

`datatuple` is a tuple in which each element is in this format:

</code></pre>

<p>(subject, message, from_email, recipient_list)</p>
<pre><code>
`fail_silently`, `auth_user` and `auth_password` have the same functions as in [`send_mail()`](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.send_mail).

Each separate element of `datatuple` results in a separate email message. As in [`send_mail()`](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.send_mail), recipients in the same `recipient_list` will all see the other addresses in the email messages” «To:» field.

For example, the following code would send two different messages to two different sets of recipients; however, only one connection to the mail server would be opened:

</code></pre>

<p>message1 = ('Subject here', 'Here is the message', 'from@example.com', ['first@example.com', 'other@example.com'])
message2 = ('Another Subject', 'Here is another message', 'from@example.com', ['second@test.com'])
send_mass_mail((message1, message2), fail_silently=False)</p>
<pre><code>
The return value will be the number of successfully delivered messages.



### `send_mass_mail()` vs. `send_mail()`[¶](https://docs.djangoproject.com/es/3.0/topics/email/#send-mass-mail-vs-send-mail)

The main difference between [`send_mass_mail()`](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.send_mass_mail) and [`send_mail()`](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.send_mail) is that [`send_mail()`](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.send_mail) opens a connection to the mail server each time it’s executed, while [`send_mass_mail()`](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.send_mass_mail) uses a single connection for all of its messages. This makes [`send_mass_mail()`](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.send_mass_mail) slightly more efficient.



## `mail_admins()`[¶](https://docs.djangoproject.com/es/3.0/topics/email/#mail-admins)

- `mail_admins`(*subject*, *message*, *fail_silently=False*, *connection=None*, *html_message=None*)[[fuente\]](https://docs.djangoproject.com/es/3.0/_modules/django/core/mail/#mail_admins)[¶](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.mail_admins)



`django.core.mail.mail_admins()` is a shortcut for sending an email to the site admins, as defined in the [`ADMINS`](https://docs.djangoproject.com/es/3.0/ref/settings/#std:setting-ADMINS) setting.

`mail_admins()` prefixes the subject with the value of the [`EMAIL_SUBJECT_PREFIX`](https://docs.djangoproject.com/es/3.0/ref/settings/#std:setting-EMAIL_SUBJECT_PREFIX) setting, which is `&quot;[Django] &quot;` by default.

The «From:» header of the email will be the value of the [`SERVER_EMAIL`](https://docs.djangoproject.com/es/3.0/ref/settings/#std:setting-SERVER_EMAIL) setting.

This method exists for convenience and readability.

If `html_message` is provided, the resulting email will be a *multipart/alternative* email with `message` as the *text/plain* content type and `html_message` as the *text/html* content type.



## `mail_managers()`[¶](https://docs.djangoproject.com/es/3.0/topics/email/#mail-managers)

- `mail_managers`(*subject*, *message*, *fail_silently=False*, *connection=None*, *html_message=None*)[[fuente\]](https://docs.djangoproject.com/es/3.0/_modules/django/core/mail/#mail_managers)[¶](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.mail_managers)



`django.core.mail.mail_managers()` is just like `mail_admins()`, except it sends an email to the site managers, as defined in the [`MANAGERS`](https://docs.djangoproject.com/es/3.0/ref/settings/#std:setting-MANAGERS) setting.



## Examples[¶](https://docs.djangoproject.com/es/3.0/topics/email/#examples)

This sends a single email to [john@example.com](mailto:john%40example.com) and [jane@example.com](mailto:jane%40example.com), with them both appearing in the «To:»:

</code></pre>

<p>send_mail(
    'Subject',
    'Message.',
    'from@example.com',
    ['john@example.com', 'jane@example.com'],
)</p>
<pre><code>
This sends a message to [john@example.com](mailto:john%40example.com) and [jane@example.com](mailto:jane%40example.com), with them both receiving a separate email:

</code></pre>

<p>datatuple = (
    ('Subject', 'Message.', 'from@example.com', ['john@example.com']),
    ('Subject', 'Message.', 'from@example.com', ['jane@example.com']),
)
send_mass_mail(datatuple)</p>
<pre><code>


## Preventing header injection[¶](https://docs.djangoproject.com/es/3.0/topics/email/#preventing-header-injection)

[Header injection](http://www.nyphp.org/phundamentals/8_Preventing-Email-Header-Injection) is a security exploit in which an attacker inserts extra email headers to control the «To:» and «From:» in email messages that your scripts generate.

The Django email functions outlined above all protect against header injection by forbidding newlines in header values. If any `subject`, `from_email` or `recipient_list` contains a newline (in either Unix, Windows or Mac style), the email function (e.g. [`send_mail()`](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.send_mail)) will raise `django.core.mail.BadHeaderError` (a subclass of `ValueError`) and, hence, will not send the email. It’s your responsibility to validate all data before passing it to the email functions.

If a `message` contains headers at the start of the string, the headers will be printed as the first bit of the email message.

Here’s an example view that takes a `subject`, `message` and `from_email` from the request’s POST data, sends that to [admin@example.com](mailto:admin%40example.com) and redirects to «/contact/thanks/» when it’s done:

</code></pre>

<p>from django.core.mail import BadHeaderError, send_mail
from django.http import HttpResponse, HttpResponseRedirect</p>
<p>def send_email(request):
    subject = request.POST.get('subject', '')
    message = request.POST.get('message', '')
    from_email = request.POST.get('from_email', '')
    if subject and message and from_email:
        try:
            send_mail(subject, message, from_email, ['admin@example.com'])
        except BadHeaderError:
            return HttpResponse('Invalid header found.')
        return HttpResponseRedirect('/contact/thanks/')
    else:
        # In reality we'd use a form class
        # to get proper validation errors.
        return HttpResponse('Make sure all fields are entered and valid.')</p>
<pre><code>


## The `EmailMessage` class[¶](https://docs.djangoproject.com/es/3.0/topics/email/#the-emailmessage-class)

Django’s [`send_mail()`](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.send_mail) and [`send_mass_mail()`](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.send_mass_mail) functions are actually thin wrappers that make use of the [`EmailMessage`](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.EmailMessage) class.

Not all features of the [`EmailMessage`](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.EmailMessage) class are available through the [`send_mail()`](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.send_mail) and related wrapper functions. If you wish to use advanced features, such as BCC’ed recipients, file attachments, or multi-part email, you’ll need to create [`EmailMessage`](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.EmailMessage) instances directly.

Nota

This is a design feature. [`send_mail()`](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.send_mail) and related functions were originally the only interface Django provided. However, the list of parameters they accepted was slowly growing over time. It made sense to move to a more object-oriented design for email messages and retain the original functions only for backwards compatibility.

[`EmailMessage`](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.EmailMessage) is responsible for creating the email message itself. The [email backend](https://docs.djangoproject.com/es/3.0/topics/email/#topic-email-backends) is then responsible for sending the email.

For convenience, [`EmailMessage`](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.EmailMessage) provides a `send()` method for sending a single email. If you need to send multiple messages, the email backend API [provides an alternative](https://docs.djangoproject.com/es/3.0/topics/email/#topics-sending-multiple-emails).



### `EmailMessage` Objects[¶](https://docs.djangoproject.com/es/3.0/topics/email/#emailmessage-objects)

- *class* `EmailMessage`[[fuente\]](https://docs.djangoproject.com/es/3.0/_modules/django/core/mail/message/#EmailMessage)[¶](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.EmailMessage)



The [`EmailMessage`](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.EmailMessage) class is initialized with the following parameters (in the given order, if positional arguments are used). All parameters are optional and can be set at any time prior to calling the `send()` method.

- `subject`: The subject line of the email.
- `body`: The body text. This should be a plain text message.
- `from_email`: The sender’s address. Both `fred@example.com` and `&quot;Fred&quot; ` forms are legal. If omitted, the [`DEFAULT_FROM_EMAIL`](https://docs.djangoproject.com/es/3.0/ref/settings/#std:setting-DEFAULT_FROM_EMAIL) setting is used.
- `to`: A list or tuple of recipient addresses.
- `bcc`: A list or tuple of addresses used in the «Bcc» header when sending the email.
- `connection`: An email backend instance. Use this parameter if you want to use the same connection for multiple messages. If omitted, a new connection is created when `send()` is called.
- `attachments`: A list of attachments to put on the message. These can be either [`MIMEBase`](https://docs.python.org/3/library/email.mime.html#email.mime.base.MIMEBase) instances, or `(filename, content, mimetype)` triples.
- `headers`: A dictionary of extra headers to put on the message. The keys are the header name, values are the header values. It’s up to the caller to ensure header names and values are in the correct format for an email message. The corresponding attribute is `extra_headers`.
- `cc`: A list or tuple of recipient addresses used in the «Cc» header when sending the email.
- `reply_to`: A list or tuple of recipient addresses used in the «Reply-To» header when sending the email.

For example:

</code></pre>

<p>from django.core.mail import EmailMessage</p>
<p>email = EmailMessage(
    'Hello',
    'Body goes here',
    'from@example.com',
    ['to1@example.com', 'to2@example.com'],
    ['bcc@example.com'],
    reply_to=['another@example.com'],
    headers={'Message-ID': 'foo'},
)</p>
<pre><code>
The class has the following methods:

- `send(fail_silently=False)` sends the message. If a connection was specified when the email was constructed, that connection will be used. Otherwise, an instance of the default backend will be instantiated and used. If the keyword argument `fail_silently` is `True`, exceptions raised while sending the message will be quashed. An empty list of recipients will not raise an exception.

- `message()` constructs a `django.core.mail.SafeMIMEText` object (a subclass of Python’s [`MIMEText`](https://docs.python.org/3/library/email.mime.html#email.mime.text.MIMEText) class) or a `django.core.mail.SafeMIMEMultipart` object holding the message to be sent. If you ever need to extend the [`EmailMessage`](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.EmailMessage) class, you’ll probably want to override this method to put the content you want into the MIME object.

- `recipients()` returns a list of all the recipients of the message, whether they’re recorded in the `to`, `cc` or `bcc` attributes. This is another method you might need to override when subclassing, because the SMTP server needs to be told the full list of recipients when the message is sent. If you add another way to specify recipients in your class, they need to be returned from this method as well.

- `attach()` creates a new file attachment and adds it to the message. There are two ways to call `attach()`:

  - You can pass it a single argument that is a [`MIMEBase`](https://docs.python.org/3/library/email.mime.html#email.mime.base.MIMEBase) instance. This will be inserted directly into the resulting message.

  - Alternatively, you can pass `attach()` three arguments: `filename`, `content` and `mimetype`. `filename` is the name of the file attachment as it will appear in the email, `content` is the data that will be contained inside the attachment and `mimetype` is the optional MIME type for the attachment. If you omit `mimetype`, the MIME content type will be guessed from the filename of the attachment.

    For example:

    ```
    message.attach('design.png', img_data, 'image/png')
    ```

    If you specify a `mimetype` of `message/rfc822`, it will also accept [`django.core.mail.EmailMessage`](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.EmailMessage) and [`email.message.Message`](https://docs.python.org/3/library/email.compat32-message.html#email.message.Message).

    For a `mimetype` starting with `text/`, content is expected to be a string. Binary data will be decoded using UTF-8, and if that fails, the MIME type will be changed to `application/octet-stream` and the data will be attached unchanged.

    In addition, `message/rfc822` attachments will no longer be base64-encoded in violation of [**RFC 2046#section-5.2.1**](https://tools.ietf.org/html/rfc2046.html#section-5.2.1), which can cause issues with displaying the attachments in [Evolution](https://bugzilla.gnome.org/show_bug.cgi?id=651197) and [Thunderbird](https://bugzilla.mozilla.org/show_bug.cgi?id=333880).

- `attach_file()` creates a new attachment using a file from your filesystem. Call it with the path of the file to attach and, optionally, the MIME type to use for the attachment. If the MIME type is omitted, it will be guessed from the filename. You can use it like this:

  ```
  message.attach_file('/images/weather_map.png')
  ```

  For MIME types starting with `text/`, binary data is handled as in `attach()`.



#### Sending alternative content types[¶](https://docs.djangoproject.com/es/3.0/topics/email/#sending-alternative-content-types)

It can be useful to include multiple versions of the content in an email; the classic example is to send both text and HTML versions of a message. With Django’s email library, you can do this using the `EmailMultiAlternatives` class. This subclass of [`EmailMessage`](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.EmailMessage) has an `attach_alternative()` method for including extra versions of the message body in the email. All the other methods (including the class initialization) are inherited directly from [`EmailMessage`](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.EmailMessage).

To send a text and HTML combination, you could write:

</code></pre>

<p>from django.core.mail import EmailMultiAlternatives</p>
<p>subject, from_email, to = 'hello', 'from@example.com', 'to@example.com'
text_content = 'This is an important message.'
html_content = '<p>This is an <strong>important</strong> message.</p>'
msg = EmailMultiAlternatives(subject, text_content, from_email, [to])
msg.attach_alternative(html_content, "text/html")
msg.send()</p>
<pre><code>
By default, the MIME type of the `body` parameter in an [`EmailMessage`](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.EmailMessage) is `&quot;text/plain&quot;`. It is good practice to leave this alone, because it guarantees that any recipient will be able to read the email, regardless of their mail client. However, if you are confident that your recipients can handle an alternative content type, you can use the `content_subtype` attribute on the [`EmailMessage`](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.EmailMessage) class to change the main content type. The major type will always be `&quot;text&quot;`, but you can change the subtype. For example:

</code></pre>

<p>msg = EmailMessage(subject, html_content, from_email, [to])
msg.content_subtype = "html"  # Main content is now text/html
msg.send()</p>
<pre><code>


## Email backends[¶](https://docs.djangoproject.com/es/3.0/topics/email/#email-backends)

The actual sending of an email is handled by the email backend.

The email backend class has the following methods:

- `open()` instantiates a long-lived email-sending connection.
- `close()` closes the current email-sending connection.
- `send_messages(email_messages)` sends a list of [`EmailMessage`](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.EmailMessage) objects. If the connection is not open, this call will implicitly open the connection, and close the connection afterwards. If the connection is already open, it will be left open after mail has been sent.

It can also be used as a context manager, which will automatically call `open()` and `close()` as needed:

</code></pre>

<p>from django.core import mail</p>
<p>with mail.get_connection() as connection:
    mail.EmailMessage(
        subject1, body1, from1, [to1],
        connection=connection,
    ).send()
    mail.EmailMessage(
        subject2, body2, from2, [to2],
        connection=connection,
    ).send()</p>
<pre><code>


### Obtaining an instance of an email backend[¶](https://docs.djangoproject.com/es/3.0/topics/email/#obtaining-an-instance-of-an-email-backend)

The [`get_connection()`](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.get_connection) function in `django.core.mail` returns an instance of the email backend that you can use.

- `get_connection`(*backend=None*, *fail_silently=False*, **args*, ***kwargs*)[[fuente\]](https://docs.djangoproject.com/es/3.0/_modules/django/core/mail/#get_connection)[¶](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.get_connection)



By default, a call to `get_connection()` will return an instance of the email backend specified in [`EMAIL_BACKEND`](https://docs.djangoproject.com/es/3.0/ref/settings/#std:setting-EMAIL_BACKEND). If you specify the `backend` argument, an instance of that backend will be instantiated.

The `fail_silently` argument controls how the backend should handle errors. If `fail_silently` is True, exceptions during the email sending process will be silently ignored.

All other arguments are passed directly to the constructor of the email backend.

Django ships with several email sending backends. With the exception of the SMTP backend (which is the default), these backends are only useful during testing and development. If you have special email sending requirements, you can [write your own email backend](https://docs.djangoproject.com/es/3.0/topics/email/#topic-custom-email-backend).



#### SMTP backend[¶](https://docs.djangoproject.com/es/3.0/topics/email/#smtp-backend)

- *class* `backends.smtp.``EmailBackend`(*host=None*, *port=None*, *username=None*, *password=None*, *use_tls=None*, *fail_silently=False*, *use_ssl=None*, *timeout=None*, *ssl_keyfile=None*, *ssl_certfile=None*, ***kwargs*)[¶](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.backends.smtp.EmailBackend)

  This is the default backend. Email will be sent through a SMTP server.The value for each argument is retrieved from the matching setting if the argument is `None`:`host`: [`EMAIL_HOST`](https://docs.djangoproject.com/es/3.0/ref/settings/#std:setting-EMAIL_HOST)`port`: [`EMAIL_PORT`](https://docs.djangoproject.com/es/3.0/ref/settings/#std:setting-EMAIL_PORT)`username`: [`EMAIL_HOST_USER`](https://docs.djangoproject.com/es/3.0/ref/settings/#std:setting-EMAIL_HOST_USER)`password`: [`EMAIL_HOST_PASSWORD`](https://docs.djangoproject.com/es/3.0/ref/settings/#std:setting-EMAIL_HOST_PASSWORD)`use_tls`: [`EMAIL_USE_TLS`](https://docs.djangoproject.com/es/3.0/ref/settings/#std:setting-EMAIL_USE_TLS)`use_ssl`: [`EMAIL_USE_SSL`](https://docs.djangoproject.com/es/3.0/ref/settings/#std:setting-EMAIL_USE_SSL)`timeout`: [`EMAIL_TIMEOUT`](https://docs.djangoproject.com/es/3.0/ref/settings/#std:setting-EMAIL_TIMEOUT)`ssl_keyfile`: [`EMAIL_SSL_KEYFILE`](https://docs.djangoproject.com/es/3.0/ref/settings/#std:setting-EMAIL_SSL_KEYFILE)`ssl_certfile`: [`EMAIL_SSL_CERTFILE`](https://docs.djangoproject.com/es/3.0/ref/settings/#std:setting-EMAIL_SSL_CERTFILE)The SMTP backend is the default configuration inherited by Django. If you want to specify it explicitly, put the following in your settings:`EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend' `If unspecified, the default `timeout` will be the one provided by [`socket.getdefaulttimeout()`](https://docs.python.org/3/library/socket.html#socket.getdefaulttimeout), which defaults to `None` (no timeout).



#### Console backend[¶](https://docs.djangoproject.com/es/3.0/topics/email/#console-backend)

Instead of sending out real emails the console backend just writes the emails that would be sent to the standard output. By default, the console backend writes to `stdout`. You can use a different stream-like object by providing the `stream` keyword argument when constructing the connection.

To specify this backend, put the following in your settings:

</code></pre>

<p>EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'</p>
<pre><code>
This backend is not intended for use in production – it is provided as a convenience that can be used during development.



#### File backend[¶](https://docs.djangoproject.com/es/3.0/topics/email/#file-backend)

The file backend writes emails to a file. A new file is created for each new session that is opened on this backend. The directory to which the files are written is either taken from the [`EMAIL_FILE_PATH`](https://docs.djangoproject.com/es/3.0/ref/settings/#std:setting-EMAIL_FILE_PATH) setting or from the `file_path` keyword when creating a connection with [`get_connection()`](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.get_connection).

To specify this backend, put the following in your settings:

</code></pre>

<p>EMAIL_BACKEND = 'django.core.mail.backends.filebased.EmailBackend'
EMAIL_FILE_PATH = '/tmp/app-messages' # change this to a proper location</p>
<pre><code>
This backend is not intended for use in production – it is provided as a convenience that can be used during development.



#### In-memory backend[¶](https://docs.djangoproject.com/es/3.0/topics/email/#in-memory-backend)

The `'locmem'` backend stores messages in a special attribute of the `django.core.mail` module. The `outbox` attribute is created when the first message is sent. It’s a list with an [`EmailMessage`](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.EmailMessage) instance for each message that would be sent.

To specify this backend, put the following in your settings:

</code></pre>

<p>EMAIL_BACKEND = 'django.core.mail.backends.locmem.EmailBackend'</p>
<pre><code>
This backend is not intended for use in production – it is provided as a convenience that can be used during development and testing.



#### Dummy backend[¶](https://docs.djangoproject.com/es/3.0/topics/email/#dummy-backend)

As the name suggests the dummy backend does nothing with your messages. To specify this backend, put the following in your settings:

</code></pre>

<p>EMAIL_BACKEND = 'django.core.mail.backends.dummy.EmailBackend'</p>
<pre><code>
This backend is not intended for use in production – it is provided as a convenience that can be used during development.



### Defining a custom email backend[¶](https://docs.djangoproject.com/es/3.0/topics/email/#defining-a-custom-email-backend)

If you need to change how emails are sent you can write your own email backend. The [`EMAIL_BACKEND`](https://docs.djangoproject.com/es/3.0/ref/settings/#std:setting-EMAIL_BACKEND) setting in your settings file is then the Python import path for your backend class.

Custom email backends should subclass `BaseEmailBackend` that is located in the `django.core.mail.backends.base` module. A custom email backend must implement the `send_messages(email_messages)` method. This method receives a list of [`EmailMessage`](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.EmailMessage) instances and returns the number of successfully delivered messages. If your backend has any concept of a persistent session or connection, you should also implement the `open()` and `close()` methods. Refer to `smtp.EmailBackend` for a reference implementation.



### Sending multiple emails[¶](https://docs.djangoproject.com/es/3.0/topics/email/#sending-multiple-emails)

Establishing and closing an SMTP connection (or any other network connection, for that matter) is an expensive process. If you have a lot of emails to send, it makes sense to reuse an SMTP connection, rather than creating and destroying a connection every time you want to send an email.

There are two ways you tell an email backend to reuse a connection.

Firstly, you can use the `send_messages()` method. `send_messages()` takes a list of [`EmailMessage`](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.EmailMessage) instances (or subclasses), and sends them all using a single connection.

For example, if you have a function called `get_notification_email()` that returns a list of [`EmailMessage`](https://docs.djangoproject.com/es/3.0/topics/email/#django.core.mail.EmailMessage) objects representing some periodic email you wish to send out, you could send these emails using a single call to send_messages:

</code></pre>

<p>from django.core import mail
connection = mail.get_connection()   # Use default email connection
messages = get_notification_email()
connection.send_messages(messages)</p>
<pre><code>
In this example, the call to `send_messages()` opens a connection on the backend, sends the list of messages, and then closes the connection again.

The second approach is to use the `open()` and `close()` methods on the email backend to manually control the connection. `send_messages()` will not manually open or close the connection if it is already open, so if you manually open the connection, you can control when it is closed. For example:

</code></pre>

<p>from django.core import mail
connection = mail.get_connection()</p>
<h1 id="manually-open-the-connection">Manually open the connection</h1>
<p>connection.open()</p>
<h1 id="construct-an-email-message-that-uses-the-connection">Construct an email message that uses the connection</h1>
<p>email1 = mail.EmailMessage(
    'Hello',
    'Body goes here',
    'from@example.com',
    ['to1@example.com'],
    connection=connection,
)
email1.send() # Send the email</p>
<h1 id="construct-two-more-messages">Construct two more messages</h1>
<p>email2 = mail.EmailMessage(
    'Hello',
    'Body goes here',
    'from@example.com',
    ['to2@example.com'],
)
email3 = mail.EmailMessage(
    'Hello',
    'Body goes here',
    'from@example.com',
    ['to3@example.com'],
)</p>
<h1 id="send-the-two-emails-in-a-single-call-">Send the two emails in a single call -</h1>
<p>connection.send_messages([email2, email3])</p>
<h1 id="the-connection-was-already-open-so-send_messages-doesnt-close-it">The connection was already open so send_messages() doesn't close it.</h1>
<h1 id="we-need-to-manually-close-the-connection">We need to manually close the connection.</h1>
<p>connection.close()</p>
<pre><code>


## Configuring email for development[¶](https://docs.djangoproject.com/es/3.0/topics/email/#configuring-email-for-development)

There are times when you do not want Django to send emails at all. For example, while developing a website, you probably don’t want to send out thousands of emails – but you may want to validate that emails will be sent to the right people under the right conditions, and that those emails will contain the correct content.

The easiest way to configure email for local development is to use the [console](https://docs.djangoproject.com/es/3.0/topics/email/#topic-email-console-backend) email backend. This backend redirects all email to stdout, allowing you to inspect the content of mail.

The [file](https://docs.djangoproject.com/es/3.0/topics/email/#topic-email-file-backend) email backend can also be useful during development – this backend dumps the contents of every SMTP connection to a file that can be inspected at your leisure.

Another approach is to use a «dumb» SMTP server that receives the emails locally and displays them to the terminal, but does not actually send anything. Python has a built-in way to accomplish this with a single command:

</code></pre>

<p>python -m smtpd -n -c DebuggingServer localhost:1025
```</p>
<p>This command will start a minimal SMTP server listening on port 1025 of localhost. This server prints to standard output all email headers and the email body. You then only need to set the <a href="https://docs.djangoproject.com/es/3.0/ref/settings/#std:setting-EMAIL_HOST"><code>EMAIL_HOST</code></a> and <a href="https://docs.djangoproject.com/es/3.0/ref/settings/#std:setting-EMAIL_PORT"><code>EMAIL_PORT</code></a> accordingly. For a more detailed discussion of SMTP server options, see the Python documentation for the <a href="https://docs.python.org/3/library/smtpd.html#module-smtpd"><code>smtpd</code></a> module.</p>
<p>For information about unit-testing the sending of emails in your application, see the <a href="https://docs.djangoproject.com/es/3.0/topics/testing/tools/#topics-testing-email">Email services</a> section of the testing documentation.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../14_newspaper_app/" class="btn btn-neutral float-right" title="14. Newspaper app">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../12_cambio_y_restauracion_de_contrasenas/" class="btn btn-neutral" title="12. Cambio y Restauración de Contraseñas"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../12_cambio_y_restauracion_de_contrasenas/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../14_newspaper_app/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>

</body>
</html>
