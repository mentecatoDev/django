{"config":{"lang":["es"],"prebuild_index":false,"separator":"[\\s\\-\\.]+"},"docs":[{"location":"","text":"Django Introducci\u00f3n Configuraci\u00f3n Inicial Hello World app Pages app Message Board app Blog app","title":"Django"},{"location":"#django","text":"","title":"Django"},{"location":"#introduccion","text":"","title":"Introducci\u00f3n"},{"location":"#configuracion-inicial","text":"","title":"Configuraci\u00f3n Inicial"},{"location":"#hello-world-app","text":"","title":"Hello World app"},{"location":"#pages-app","text":"","title":"Pages app"},{"location":"#message-board-app","text":"","title":"Message Board app"},{"location":"#blog-app","text":"","title":"Blog app"},{"location":"1_introduccion/","text":"1 Introducci\u00f3n Aprendizaje basado en proyectos 5 Proyectos progresivos Libre y Open Source Lo que hace que Django sea impresionante es su filosof\u00eda de \"viene en la caja\" \u00f3 \"pilas incluidas\" ( \"comes with the box\" \u00f3 \"batteries-included\" ). Permite una r\u00e1pida implementaci\u00f3n porque las partes m\u00e1s importantes ya est\u00e1n all\u00ed. Robusto Instagram, Pinterest (Flask; m\u00e1s personalizable y adecuado para API's), Bitbucket, Disqus, Nasa, Mozilla Firefox, Onion, Mahalo, The Washington Post, Eventbrite Se usar\u00e1 pipenv 1.1 Por qu\u00e9 Django \"comes with the box\" \u00f3 \"batteries-included\" La mayor\u00eda de los sites usan las mismas funcionalidades b\u00e1sicas Autenticaci\u00f3n de usuarios Conexi\u00f3n a bases de datos Rutas Contenidos de una p\u00e1gina Gesti\u00f3n de la seguridad Interfaz de administraci\u00f3n etc. Hay que centrarse en nuevas funcionalidades: no reinventar la rueda. Django abraza el \"batteries-included\" frente a la aproximaci\u00f3n \"microframework\" (Flask). Menos flexible pero tambi\u00e9n menos tendente al error (Django) frente a m\u00e1s personalizable y simple (Flask). Es un entorno muy maduro (2005). Aprendamos de las mejores pr\u00e1cticas. 1.2 Por qu\u00e9 unos apuntes Django est\u00e1 bien documentado pero es dif\u00edcil de abordar para el principiante Incluso el tutorial b\u00e1sico es notablemente arduo El problema viene de que est\u00e1 orientado a la profundidad y no a la facilidad de uso Aunque no es estrictamente necesario, se recomienda tener conocimientos sobre Python, HTML y CSS 1.3 Estructura 1.Configuraci\u00f3n inicial Django 3.0 Python 3.8 Pipenv Visual Studio Codium Terminal 2.Aplicaci\u00f3n \"Hello World\" Configuraci\u00f3n de un proyecto Django Git/GitLab (BitBucker?) 3.Aplicaci\u00f3n \"Pages\" Don't Repeat Yourserlf (DRY) Platform as a service (PaaS): Heroku? 4.Aplicaci\u00f3n \"Message Board\" Bases de datos: ORM Test Bitbucker? Heroku? 5-7.Aplicaci\u00f3n \"Blog\" CRUD (Create-Read-Update-Delete) log in, log out, sign up 8.Aplicaci\u00f3n \"Newspaper\" Concepto de \"Custom user models\" 9.Autenticaci\u00f3n de usuarios 10.Bootstrap 11-12.Reseteo y cambio de contrase\u00f1as v\u00eda email 13-15.Art\u00edculos y comentarios para \"Newspaper\" 16.Conclusi\u00f3n Estamos preparados para empezar a aprender programaci\u00f3n","title":"1. Introducci\u00f3n"},{"location":"1_introduccion/#1-introduccion","text":"Aprendizaje basado en proyectos 5 Proyectos progresivos Libre y Open Source Lo que hace que Django sea impresionante es su filosof\u00eda de \"viene en la caja\" \u00f3 \"pilas incluidas\" ( \"comes with the box\" \u00f3 \"batteries-included\" ). Permite una r\u00e1pida implementaci\u00f3n porque las partes m\u00e1s importantes ya est\u00e1n all\u00ed. Robusto Instagram, Pinterest (Flask; m\u00e1s personalizable y adecuado para API's), Bitbucket, Disqus, Nasa, Mozilla Firefox, Onion, Mahalo, The Washington Post, Eventbrite Se usar\u00e1 pipenv","title":"1 Introducci\u00f3n"},{"location":"1_introduccion/#11-por-que-django-comes-with-the-box-o-batteries-included","text":"La mayor\u00eda de los sites usan las mismas funcionalidades b\u00e1sicas Autenticaci\u00f3n de usuarios Conexi\u00f3n a bases de datos Rutas Contenidos de una p\u00e1gina Gesti\u00f3n de la seguridad Interfaz de administraci\u00f3n etc. Hay que centrarse en nuevas funcionalidades: no reinventar la rueda. Django abraza el \"batteries-included\" frente a la aproximaci\u00f3n \"microframework\" (Flask). Menos flexible pero tambi\u00e9n menos tendente al error (Django) frente a m\u00e1s personalizable y simple (Flask). Es un entorno muy maduro (2005). Aprendamos de las mejores pr\u00e1cticas.","title":"1.1 Por qu\u00e9 Django \"comes with the box\" \u00f3 \"batteries-included\""},{"location":"1_introduccion/#12-por-que-unos-apuntes","text":"Django est\u00e1 bien documentado pero es dif\u00edcil de abordar para el principiante Incluso el tutorial b\u00e1sico es notablemente arduo El problema viene de que est\u00e1 orientado a la profundidad y no a la facilidad de uso Aunque no es estrictamente necesario, se recomienda tener conocimientos sobre Python, HTML y CSS","title":"1.2 Por qu\u00e9 unos apuntes"},{"location":"1_introduccion/#13-estructura","text":"1.Configuraci\u00f3n inicial Django 3.0 Python 3.8 Pipenv Visual Studio Codium Terminal 2.Aplicaci\u00f3n \"Hello World\" Configuraci\u00f3n de un proyecto Django Git/GitLab (BitBucker?) 3.Aplicaci\u00f3n \"Pages\" Don't Repeat Yourserlf (DRY) Platform as a service (PaaS): Heroku? 4.Aplicaci\u00f3n \"Message Board\" Bases de datos: ORM Test Bitbucker? Heroku? 5-7.Aplicaci\u00f3n \"Blog\" CRUD (Create-Read-Update-Delete) log in, log out, sign up 8.Aplicaci\u00f3n \"Newspaper\" Concepto de \"Custom user models\" 9.Autenticaci\u00f3n de usuarios 10.Bootstrap 11-12.Reseteo y cambio de contrase\u00f1as v\u00eda email 13-15.Art\u00edculos y comentarios para \"Newspaper\" 16.Conclusi\u00f3n Estamos preparados para empezar a aprender programaci\u00f3n","title":"1.3 Estructura"},{"location":"2_configuracion_inicial/","text":"2 Configuraci\u00f3n inicial Objetivos Configurar el entorno para programar en proyectos Django Uso de la l\u00ednea de comandos para instalar: Django 3.0 Python 3.8 Git Editor de texto 2.1 La l\u00ednea de comandos Konsole, Tmux, zsh cd, cd .., ls, pwd, mkdir, touch Pr\u00e1ctica: Recorrer los directorios del sistema, hacer una lista de ellos Mostrar el directorio de trabajo Crear un nuevo directorio y crear un fichero index.html en \u00e9l Listar el fichero: formato largo, ficheros ocultos D\u00f3nde aprender OpenWebinars Command Line Crash Course CodeAcademy's Course on the Command Line 2.2 Instalar Python 3 Entornos Virtuales Instrucciones de instalaci\u00f3n desde los ficheros fuentes 2.3 Entornos Virtuales Ver: https://mentecatodev.github.io/intermezzo/entornos_virtuales/ 2.4 Instalaci\u00f3n de Django $ cd ~/Escritorio $ mkdir django $ cd django $ pipenv install django $ pipenv shell Crear nuevo proyecto test . No olvidar el \".\" al final. $ django-admin startproject test_project . Si no se usa el \".\" aparecer\u00e1 la siguiente estructura \u2514\u2500\u2500test_project \u251c\u2500\u2500 manage.py \u2514\u2500\u2500 test_project \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 settings.py \u251c\u2500\u2500 urls.py \u2514\u2500\u2500 wsgi.py Arrancando el servidor $ python manage.py runserver Escribir en el navegador la url http://127.0.0.1:8000/ o http://localhost:8000 <Ctrl>-c para parar exit para salir del entorno virtual 2.5.1 Cambiando la IP de escucha y el puerto De manera predeterminada, el comando runserver inicia el servidor de desarrollo en la IP interna en el puerto 8000. Si se desea cambiar el puerto del servidor, hay que pasarlo como un argumento de l\u00ednea de comandos. Por ejemplo, este comando inicia el servidor en el puerto 8080: $ python manage.py runserver 8080 Si se desea cambiar la IP del servidor, ejecutar el comando con la IP seguida del puerto. Por ejemplo, para escuchar todas las IP p\u00fablicas disponibles (lo cual es \u00fatil si se est\u00e1 ejecutando Vagrant o se desea mostrar la web en otras computadoras en la red), usar: $ python manage.py runserver 0:8000 0 es un atajo para 0.0.0.0 . Los documentos completos para el servidor de desarrollo se pueden encontrar en la referencia del servidor de ejecuci\u00f3n. Si se ejecuta este script como un usuario sin privilegios (recomendado), es posible que no se tenga acceso para iniciar en un puerto con un n\u00famero bajo. Los n\u00fameros de puerto bajos est\u00e1n reservados para el superusuario (root). Una descripci\u00f3n m\u00e1s detallada del servidor se puede encontrar aqu\u00ed . 2.5 Instalar Git $ sudo apt install git $ git config --global user.name \"<Nombre>\" $ git config --globar user.email \"<Correo electr\u00f3nico>\" 2.6 Editores de texto Emacs \u00f3 Vim Code-OSS \u00f3 Visual Studio Codium PyCharm 2.7 Conclusi\u00f3n","title":"2. Configuraci\u00f3n Inicial"},{"location":"2_configuracion_inicial/#2-configuracion-inicial","text":"Objetivos Configurar el entorno para programar en proyectos Django Uso de la l\u00ednea de comandos para instalar: Django 3.0 Python 3.8 Git Editor de texto","title":"2 Configuraci\u00f3n inicial"},{"location":"2_configuracion_inicial/#21-la-linea-de-comandos","text":"Konsole, Tmux, zsh cd, cd .., ls, pwd, mkdir, touch Pr\u00e1ctica: Recorrer los directorios del sistema, hacer una lista de ellos Mostrar el directorio de trabajo Crear un nuevo directorio y crear un fichero index.html en \u00e9l Listar el fichero: formato largo, ficheros ocultos D\u00f3nde aprender OpenWebinars Command Line Crash Course CodeAcademy's Course on the Command Line","title":"2.1 La l\u00ednea de comandos"},{"location":"2_configuracion_inicial/#22-instalar-python-3","text":"Entornos Virtuales Instrucciones de instalaci\u00f3n desde los ficheros fuentes","title":"2.2 Instalar Python 3"},{"location":"2_configuracion_inicial/#23-entornos-virtuales","text":"Ver: https://mentecatodev.github.io/intermezzo/entornos_virtuales/","title":"2.3 Entornos Virtuales"},{"location":"2_configuracion_inicial/#24-instalacion-de-django","text":"$ cd ~/Escritorio $ mkdir django $ cd django $ pipenv install django $ pipenv shell Crear nuevo proyecto test . No olvidar el \".\" al final. $ django-admin startproject test_project . Si no se usa el \".\" aparecer\u00e1 la siguiente estructura \u2514\u2500\u2500test_project \u251c\u2500\u2500 manage.py \u2514\u2500\u2500 test_project \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 settings.py \u251c\u2500\u2500 urls.py \u2514\u2500\u2500 wsgi.py Arrancando el servidor $ python manage.py runserver Escribir en el navegador la url http://127.0.0.1:8000/ o http://localhost:8000 <Ctrl>-c para parar exit para salir del entorno virtual","title":"2.4 Instalaci\u00f3n de Django"},{"location":"2_configuracion_inicial/#251-cambiando-la-ip-de-escucha-y-el-puerto","text":"De manera predeterminada, el comando runserver inicia el servidor de desarrollo en la IP interna en el puerto 8000. Si se desea cambiar el puerto del servidor, hay que pasarlo como un argumento de l\u00ednea de comandos. Por ejemplo, este comando inicia el servidor en el puerto 8080: $ python manage.py runserver 8080 Si se desea cambiar la IP del servidor, ejecutar el comando con la IP seguida del puerto. Por ejemplo, para escuchar todas las IP p\u00fablicas disponibles (lo cual es \u00fatil si se est\u00e1 ejecutando Vagrant o se desea mostrar la web en otras computadoras en la red), usar: $ python manage.py runserver 0:8000 0 es un atajo para 0.0.0.0 . Los documentos completos para el servidor de desarrollo se pueden encontrar en la referencia del servidor de ejecuci\u00f3n. Si se ejecuta este script como un usuario sin privilegios (recomendado), es posible que no se tenga acceso para iniciar en un puerto con un n\u00famero bajo. Los n\u00fameros de puerto bajos est\u00e1n reservados para el superusuario (root). Una descripci\u00f3n m\u00e1s detallada del servidor se puede encontrar aqu\u00ed .","title":"2.5.1 Cambiando la IP de escucha y el puerto"},{"location":"2_configuracion_inicial/#25-instalar-git","text":"$ sudo apt install git $ git config --global user.name \"<Nombre>\" $ git config --globar user.email \"<Correo electr\u00f3nico>\"","title":"2.5 Instalar Git"},{"location":"2_configuracion_inicial/#26-editores-de-texto","text":"Emacs \u00f3 Vim Code-OSS \u00f3 Visual Studio Codium PyCharm","title":"2.6 Editores de texto"},{"location":"2_configuracion_inicial/#27-conclusion","text":"","title":"2.7 Conclusi\u00f3n"},{"location":"3_hello_world_app/","text":"3 Hello World app Objetivo: Crear la t\u00edpica aplicaci\u00f3n \"Hello World\" 3.1 Configuraci\u00f3n inicial $ cd ~/Escritorio $ mkdir helloworld $ cd helloworld $ pipenv install django $ pipenv shell (helloworld) $ django-admin startproject helloworld_project . (helloworld) $ sudo apt install tree (helloworld) $ tree . \u251c\u2500\u2500 Pipfile \u251c\u2500\u2500 Pipfile.lock \u251c\u2500\u2500 helloworld_project \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 settings.py \u2502 \u251c\u2500\u2500 urls.py \u2502 \u2514\u2500\u2500 wsgi.py \u2514\u2500\u2500 manage.py 1 directory, 7 files settings.py : Controla la configuraci\u00f3n del proyecto urls.py : Indica a Django qu\u00e9 p\u00e1ginas construir en respuesta a una petici\u00f3n de URL wsgi.py : ( Web Server Gateway Interface ) Punto de entrada para servidores web compatibles con WSGI para servir el proyecto. asgi.py : ( Asynchronous Server Gateway Interface ) Punto de entrada para servidores web compatibles con ASGI para servir el proyecto (nuevo en la versi\u00f3n 3.0). manage.py : Ejecuta varios comandos Django, como correr el servidor web local o crear una nueva app (helloworld) $ python manage.py runserver Visitar: http://localhost:8000 3.2 Crear una app Un proyecto Django consta de una o m\u00e1s apps Cada app resuelve una funcionalidad concreta Crear la app pages (helloworld) $ python manage.py startapp pages (helloworld) $ tree \u251c\u2500\u2500 pages \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 admin.py \u2502 \u251c\u2500\u2500 apps.py \u2502 \u251c\u2500\u2500 migrations \u2502 \u2502 \u2514\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 models.py \u2502 \u251c\u2500\u2500 tests.py \u2502 \u2514\u2500\u2500 views.py Nuevos FICHEROS admin.py : Es un fichero de configuraci\u00f3n para la app incorporada al Admin de Django apps.py : Es una fichero de configuraci\u00f3n para la propia app migrations/ : Manteniene el seguimiento de cualquier cambio en el fichero models.py para que la base de datos y el fichero models.py est\u00e9n sincronizados models.py : Es donde se define el modelo de la base de datos que Django traduce en tablas dentro de la base de datos autom\u00e1ticamente. tests.py : Es para los tests espec\u00edficos de la app views.py : Es donde se gestiona la l\u00f3gica petici\u00f3n/respuesta ( request/response ) de la app Aunque la app existe, Django no sabe nada de ella hasta que expl\u00edcitamente se la a\u00f1adimos. Para incluir la app en el proyecto se necesita a;adir una referencia a su clase de configuraci\u00f3n en la lista INSTALLED_APPS . La clase PagesConfig class est\u00e1 en el archivo pages/apps.py , por eso su path con puntos es 'pages.apps.PagesConfig' . FICHERO: settings.py ... # helloworld_project/settings.py INSTALLED_APPS = [ \u00e7 'pages.apps.PagesConfig', 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', ] ... Ojo, el orden importa; si varias aplicaciones intentan acceder al mismo recurso, la app que aparece primero tiene preferencia. 3.3 Vistas (Views) y configurariones de URL's (URLConfs) En Django , las vistas determinan qu\u00e9 contenido se muestra mientras que URLConfs indica d\u00f3nde va ese contendio. URLConf utiliza una expresi\u00f3n regular para mapear las peticiones a la funci\u00f3n apropiada de la vista que devuelve los datos correctos. La vista saca el texto Hello, World mientras que la url se asegurar\u00e1 de que cuando el usuario visita la p\u00e1gina sea redireccionado a la vista correcta. Cuando se escribe una URL, lo primero que ocurre dentro del proyecto Django es que se encuentra un patr\u00f3n que coincide con la p\u00e1gina de inicio ( homepage ). El urlpattern especifica una vista , que determinar\u00e1 el contenido de la p\u00e1gina (normalmente desde una base de datos), y una plantilla ( template ) para darle estilo. El resultado final se devuelve al usuario como una respuesta HTTP. URL -> View -> Model (t\u00edpicamente) -> Template Se empieza actualizando el fichero views.py FICHERO: pages/views.py from django.shortcuts import render \u00e7 from django.http import HttpResponse # Create your views here. \u00e7 def homePageView(request): \u00e7 return HttpResponse(\"Hello, World!\") B\u00e1sicamente se indica que siempre que se llame a la funci\u00f3n de la vista homePageView se devolver\u00e1 el texto \u201cHello, World!\u201d . M\u00e1s espec\u00edficamente se ha importado el m\u00e9todo HttpResponse para poder devolver un objeto respuesta al usuario. Ahora a configurar urls . Crear un nuevo archivo urls.py dentro del directorio pages . (helloworld) $ touch pages/urls.py A\u00f1adir el c\u00f3digo FICHERO: pages/urls.py \u00e7 # pages/urls.py \u00e7 from django.urls import path \u00e7 from .views import homePageView \u00e7 urlpatterns = [ \u00e7 path('', homePageView, name='home') \u00e7 ] Importamos path .views utiliza \".\" para indicar el directorio actual El patr\u00f3n urlpattern tiene tres partes: Un expresi\u00f3n regular Python para la cadena vac\u00eda '' Especifica la vista que se llamar\u00e1: homePageView A\u00f1ade un nombre de URL opcional home Es decir, si el usuario requiere la pagina de inicio, representada por la cadena vac\u00eda, entonces utilizar la vista llamada homePageView El \u00faltimo paso es configurar el fichero urls.py a nivel de proyecto donde se recogen todas las apps dentro de un proyecto Django, dado que cada una precisa de su propia ruta . FICHERO: helloworld_project/urls.py from django.contrib import admin \u00e7 from django.urls import path, include urlpatterns = [ path('admin/', admin.site.urls), \u00e7 path('', include('pages.urls')), ] Puede confundir un poco que no se necesite importar la app pages pero ya se hace referencia en urlpatterns como pages.urls . La raz\u00f3n de hacerlo as\u00ed es que el m\u00e9todo django.urls.include() ya recibe un m\u00f3dulo, o app , como primer argumento. As\u00ed que, sin usar include , habr\u00eda que importar la app pages pero, como s\u00ed que se usa, no se necesita a nivel de proyecto. 3.4 Resumen 1.- CREAR APP (helloworld) $ python manage.py startapp pages 2.- INFORMAR DE LA NUEVA APP FICHERO: settings.py ... INSTALLED_APPS = [ \u00e7 'pages.apps.PagesConfig', ... 3.- CREAR LA VISTA FICHERO: pages/views.py from django.shortcuts import render \u00e7 from django.http import HttpResponse # Create your views here. \u00e7 def homePageView(request): \u00e7 return HttpResponse(\"Hello, World!\") 4.- CREAR EL FICHERO DE RUTAS DE LA APP FICHERO: pages/urls.py \u00e7 from django.urls import path \u00e7 from .views import homePageView \u00e7 urlpatterns = [ \u00e7 path('', homePageView, name='home') \u00e7 ] 5.- INCLUIR EL FICHERO DE RUTAS DE LA APP EN EL PRINCIPAL FICHERO: helloworld_project/urls.py from django.contrib import admin \u00e7 from django.urls import path, include urlpatterns = [ path('admin/', admin.site.urls), \u00e7 path('', include('pages.urls')), ]","title":"3. Hello World app"},{"location":"3_hello_world_app/#3-hello-world-app","text":"Objetivo: Crear la t\u00edpica aplicaci\u00f3n \"Hello World\"","title":"3 Hello World app"},{"location":"3_hello_world_app/#31-configuracion-inicial","text":"$ cd ~/Escritorio $ mkdir helloworld $ cd helloworld $ pipenv install django $ pipenv shell (helloworld) $ django-admin startproject helloworld_project . (helloworld) $ sudo apt install tree (helloworld) $ tree . \u251c\u2500\u2500 Pipfile \u251c\u2500\u2500 Pipfile.lock \u251c\u2500\u2500 helloworld_project \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 settings.py \u2502 \u251c\u2500\u2500 urls.py \u2502 \u2514\u2500\u2500 wsgi.py \u2514\u2500\u2500 manage.py 1 directory, 7 files settings.py : Controla la configuraci\u00f3n del proyecto urls.py : Indica a Django qu\u00e9 p\u00e1ginas construir en respuesta a una petici\u00f3n de URL wsgi.py : ( Web Server Gateway Interface ) Punto de entrada para servidores web compatibles con WSGI para servir el proyecto. asgi.py : ( Asynchronous Server Gateway Interface ) Punto de entrada para servidores web compatibles con ASGI para servir el proyecto (nuevo en la versi\u00f3n 3.0). manage.py : Ejecuta varios comandos Django, como correr el servidor web local o crear una nueva app (helloworld) $ python manage.py runserver Visitar: http://localhost:8000","title":"3.1 Configuraci\u00f3n inicial"},{"location":"3_hello_world_app/#32-crear-una-app","text":"Un proyecto Django consta de una o m\u00e1s apps Cada app resuelve una funcionalidad concreta Crear la app pages (helloworld) $ python manage.py startapp pages (helloworld) $ tree \u251c\u2500\u2500 pages \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 admin.py \u2502 \u251c\u2500\u2500 apps.py \u2502 \u251c\u2500\u2500 migrations \u2502 \u2502 \u2514\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 models.py \u2502 \u251c\u2500\u2500 tests.py \u2502 \u2514\u2500\u2500 views.py Nuevos FICHEROS admin.py : Es un fichero de configuraci\u00f3n para la app incorporada al Admin de Django apps.py : Es una fichero de configuraci\u00f3n para la propia app migrations/ : Manteniene el seguimiento de cualquier cambio en el fichero models.py para que la base de datos y el fichero models.py est\u00e9n sincronizados models.py : Es donde se define el modelo de la base de datos que Django traduce en tablas dentro de la base de datos autom\u00e1ticamente. tests.py : Es para los tests espec\u00edficos de la app views.py : Es donde se gestiona la l\u00f3gica petici\u00f3n/respuesta ( request/response ) de la app Aunque la app existe, Django no sabe nada de ella hasta que expl\u00edcitamente se la a\u00f1adimos. Para incluir la app en el proyecto se necesita a;adir una referencia a su clase de configuraci\u00f3n en la lista INSTALLED_APPS . La clase PagesConfig class est\u00e1 en el archivo pages/apps.py , por eso su path con puntos es 'pages.apps.PagesConfig' . FICHERO: settings.py ... # helloworld_project/settings.py INSTALLED_APPS = [ \u00e7 'pages.apps.PagesConfig', 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', ] ... Ojo, el orden importa; si varias aplicaciones intentan acceder al mismo recurso, la app que aparece primero tiene preferencia.","title":"3.2 Crear una app"},{"location":"3_hello_world_app/#33-vistas-views-y-configurariones-de-urls-urlconfs","text":"En Django , las vistas determinan qu\u00e9 contenido se muestra mientras que URLConfs indica d\u00f3nde va ese contendio. URLConf utiliza una expresi\u00f3n regular para mapear las peticiones a la funci\u00f3n apropiada de la vista que devuelve los datos correctos. La vista saca el texto Hello, World mientras que la url se asegurar\u00e1 de que cuando el usuario visita la p\u00e1gina sea redireccionado a la vista correcta. Cuando se escribe una URL, lo primero que ocurre dentro del proyecto Django es que se encuentra un patr\u00f3n que coincide con la p\u00e1gina de inicio ( homepage ). El urlpattern especifica una vista , que determinar\u00e1 el contenido de la p\u00e1gina (normalmente desde una base de datos), y una plantilla ( template ) para darle estilo. El resultado final se devuelve al usuario como una respuesta HTTP. URL -> View -> Model (t\u00edpicamente) -> Template Se empieza actualizando el fichero views.py FICHERO: pages/views.py from django.shortcuts import render \u00e7 from django.http import HttpResponse # Create your views here. \u00e7 def homePageView(request): \u00e7 return HttpResponse(\"Hello, World!\") B\u00e1sicamente se indica que siempre que se llame a la funci\u00f3n de la vista homePageView se devolver\u00e1 el texto \u201cHello, World!\u201d . M\u00e1s espec\u00edficamente se ha importado el m\u00e9todo HttpResponse para poder devolver un objeto respuesta al usuario. Ahora a configurar urls . Crear un nuevo archivo urls.py dentro del directorio pages . (helloworld) $ touch pages/urls.py A\u00f1adir el c\u00f3digo FICHERO: pages/urls.py \u00e7 # pages/urls.py \u00e7 from django.urls import path \u00e7 from .views import homePageView \u00e7 urlpatterns = [ \u00e7 path('', homePageView, name='home') \u00e7 ] Importamos path .views utiliza \".\" para indicar el directorio actual El patr\u00f3n urlpattern tiene tres partes: Un expresi\u00f3n regular Python para la cadena vac\u00eda '' Especifica la vista que se llamar\u00e1: homePageView A\u00f1ade un nombre de URL opcional home Es decir, si el usuario requiere la pagina de inicio, representada por la cadena vac\u00eda, entonces utilizar la vista llamada homePageView El \u00faltimo paso es configurar el fichero urls.py a nivel de proyecto donde se recogen todas las apps dentro de un proyecto Django, dado que cada una precisa de su propia ruta . FICHERO: helloworld_project/urls.py from django.contrib import admin \u00e7 from django.urls import path, include urlpatterns = [ path('admin/', admin.site.urls), \u00e7 path('', include('pages.urls')), ] Puede confundir un poco que no se necesite importar la app pages pero ya se hace referencia en urlpatterns como pages.urls . La raz\u00f3n de hacerlo as\u00ed es que el m\u00e9todo django.urls.include() ya recibe un m\u00f3dulo, o app , como primer argumento. As\u00ed que, sin usar include , habr\u00eda que importar la app pages pero, como s\u00ed que se usa, no se necesita a nivel de proyecto.","title":"3.3 Vistas (Views) y configurariones de URL's (URLConfs)"},{"location":"3_hello_world_app/#34-resumen","text":"","title":"3.4 Resumen"},{"location":"3_hello_world_app/#1-crear-app","text":"(helloworld) $ python manage.py startapp pages","title":"1.- CREAR APP"},{"location":"3_hello_world_app/#2-informar-de-la-nueva-app","text":"FICHERO: settings.py ... INSTALLED_APPS = [ \u00e7 'pages.apps.PagesConfig', ...","title":"2.- INFORMAR DE LA NUEVA APP"},{"location":"3_hello_world_app/#3-crear-la-vista","text":"FICHERO: pages/views.py from django.shortcuts import render \u00e7 from django.http import HttpResponse # Create your views here. \u00e7 def homePageView(request): \u00e7 return HttpResponse(\"Hello, World!\")","title":"3.- CREAR LA VISTA"},{"location":"3_hello_world_app/#4-crear-el-fichero-de-rutas-de-la-app","text":"FICHERO: pages/urls.py \u00e7 from django.urls import path \u00e7 from .views import homePageView \u00e7 urlpatterns = [ \u00e7 path('', homePageView, name='home') \u00e7 ]","title":"4.- CREAR EL FICHERO DE RUTAS DE LA APP"},{"location":"3_hello_world_app/#5-incluir-el-fichero-de-rutas-de-la-app-en-el-principal","text":"FICHERO: helloworld_project/urls.py from django.contrib import admin \u00e7 from django.urls import path, include urlpatterns = [ path('admin/', admin.site.urls), \u00e7 path('', include('pages.urls')), ]","title":"5.- INCLUIR EL FICHERO DE RUTAS DE LA APP EN EL PRINCIPAL"},{"location":"4_pages_app/","text":"4 Pages app 4.1 Objetivos Desplegar la app Pages con una p\u00e1gina homepage y una about Vistas basadas en clases y plantillas (templates) 4.2 Configuraci\u00f3n inicial Crear un nuevo directorio para el c\u00f3digo Instalar Django en un nuevo entorno virtual Crear un nuevo projecto Django Crear una nueva app pages Actualizar settings.py $ cd ~/Desktop $ mkdir pages $ cd pages $ pipenv install --python 3.8 $ pipenv install django $ pipenv shell (pages) $ django-admin startproject pages_project . (pages) $ python manage.py startapp pages # \u00f3 (pages) $ django-admin startproject pages FICHERO: pages_project/settings.py # pages_project/settings.py ... INSTALLED_APPS = [ \u00e7 'pages.apps.PagesConfig', ... Arrancar servidor (pages) $ python manage.py runserver 4.3 Plantillas (Templates) Cada framework precisa generar de alguna manera ficheros HTML. En Django, la aproximaci\u00f3n es usar plantillas (templates) de tal forma que los archivos HTML individuales puedan ser servidos por una vista a la p\u00e1gina web especificada por la ruta (URL). Plantilla \u2013> Vista \u2013> Ruta Ruta (URL).- Controla la ruta inicial Vista (View).- Contiene la l\u00f3gica (el qu\u00e9). En p\u00e1ginas relacionadas con BD es lo que hace la mayor parte del trabajo en cuanto a decidir qu\u00e9 datos estar\u00e1n disponibles para la plantilla. Plantilla (Template).- Contiene el HTML. 4.3.1 D\u00f3nde colocar el directorio de plantillas Por defecto , Django mira dentro de cada app en busca de plantillas. En la app pages se crear\u00e1 una estructura de directorios como la siguiente con la plantilla home.html colgando de ella: \u2514\u2500\u2500 pages \u251c\u2500\u2500 templates \u251c\u2500\u2500 pages \u251c\u2500\u2500 home.html La otra aproximaci\u00f3n es hacer un directorio de plantillas com\u00fan a todas las apps. Hay que cambiar settings.py para que busque, tambi\u00e9n en este directorio, las plantillas que se necesiten. (pages) $ mkdir templates (pages) $ touch templates/home.html FICHERO: pages_project/settings.py TEMPLATES = [ { ... \u00e7 'DIRS': [os.path.join(BASE_DIR, 'templates')], ... }, ] La funci\u00f3n os.path.join une el path base de la aplicaci\u00f3n ( BASE_DIR ) con el nuevo directorio templates a\u00f1adiendo / seg\u00fan sea conveniente FICHERO: templates/home.html <h1>Homepage</h1> Ahora es el turno de la ruta y la vista 4.4 Vistas basadas en clases (Class-Based Views) Las primeras versiones de Django solo inclu\u00edan vistas basadas en funciones , pero los desarrolladores pronto se encontraron repitiendo los mismos patrones una y otra vez. Sin embargo, no hab\u00eda una manera f\u00e1cil de ampliar o personalizar estas vistas. Django introdujo vistas gen\u00e9ricas basadas en clases que facilitan el uso y tambi\u00e9n ampl\u00edan las vistas que cubren casos de uso comunes. En el ejemplo se usar\u00e1 la clase TemplateView incorporada para mostrar la plantilla. FICHERO: pages/views.py from django.views.generic import TemplateView class HomePageView(TemplateView): template_name = 'home.html' Dist\u00edngase c\u00f3mo se ha puesto en may\u00fasculas la vista, porque ahora es una clase, y c\u00f3mo \u00e9sta es descendiente de la clase base TemplateView . 1.4.5 URLs El \u00faltimo paso es actualizar los URLConfs . FICHERO: pages_project/urls.py from django.contrib import admin \u00e7 from django.urls import path, include urlpatterns = [ path('admin/', admin.site.urls), \u00e7 path('', include('pages.urls')), ] FICHERO: pages/urls.py from django.urls import path from .views import HomePageView urlpatterns = [ path('', HomePageView.as_view(), name='home'), ] Este patr\u00f3n es casi id\u00e9ntico al que se hizo anteriormente, con una sola diferencia; cuando se usan vistas basadas en clases, siempre se a\u00f1ade as_view() al final de su nombre. Iniciar el servidor para ver la nueva p\u00e1gina de inicio. 4.6 A\u00f1adir una p\u00e1gina \"Acerca de...\" Crear un nuevo fichero de plantilla (pages) $ touch templates/about.html FICHERO: templates/about.html <h1>About page</h1> Crear una nueva vista para la p\u00e1gina FICHERO: pages/views.py from django.views.generic import TemplateView class HomePageView(TemplateView): template_name = 'home.html' class AboutPageView(TemplateView): template_name = 'about.html' Conectar la vista con la ruta FICHERO: pages/urls.py from django.urls import path \u00e7 from .views import HomePageView, AboutPageView urlpatterns = [ \u00e7 path('about/', AboutPageView.as_view(), name='about'), path('', HomePageView.as_view(), name='home'), ] Lanzar http://localhost:8000/about 4.7 Extending Templates El poder real de las plantillas es la posibilidad de ser extendidas. En las mayor\u00eda de webs encontramos contenido que se repite en cada p\u00e1gina: Hagamos una p\u00e1gina can\u00f3nica que ser\u00e1 heredada por las dem\u00e1s Django tiene un lenguaje m\u00ednimo de plantillas para a\u00f1adirles enlaces y l\u00f3gica b\u00e1sica Los tags de las plantillas tienen la forma {%&ltcualquier cosa&gt%} Para a\u00f1adir enlaces a nuestro proyecto podemos usar la etiqueta de plantilla url incorporada que toma un patr\u00f3n de URL como argumento. El tag url utiliza los nombres opcionales de URL para crear enlaces autom\u00e1ticos por nosotros. Por ejemplo: {% url 'home' %} FICHERO: templates/base.html <header> <a href=\"{% url 'home' %}\">Home</a> | <a href=\"{% url 'about' %}\">About</a> </header> {% block content %} {% endblock content %} Al final se a\u00f1ade un tag block llamado content . Los bloques pueden ser reescritos por las vistas descencientes. El lenguaje de plantillas de Django dispone de un m\u00e9todo extends que puede usarse para actualizar home.html y about.html y as\u00ed extender la plantilla base.html . FICHERO: templates/home.html {% extends 'base.html' %} {% block content %} <h1>Homepage</h1> {% endblock content %} FICHERO: templates/about.html {% extends 'base.html' %} {% block content %} <h1>About page</h1> {% endblock content %} 4.8 Tests Importancia de los tests Jaco Kaplan-Moss : \"Code without tests is broken as designed.\" (El c\u00f3digo sin pruebas se rompe seg\u00fan se dise\u00f1\u00f3) Django nos brinda herramientas para escribir y correr tests. FICHERO: pages/tests.py \u00e7 from django.test import SimpleTestCase \u00e7 class SimpleTests(SimpleTestCase): \u00e7 def test_home_page_status_code(self): \u00e7 response = self.client.get('/') \u00e7 self.assertEqual(response.status_code, 200) \u00e7 def test_about_page_status_code(self): \u00e7 response = self.client.get('/about/') \u00e7 self.assertEqual(response.status_code, 200) Se usa SimpleTestCase ya que no estamos usando una base de datos. Si estuvi\u00e9ramos usando una base de datos, en su lugar usar\u00edamos TestCase . Luego se realiza una comprobaci\u00f3n de si el c\u00f3digo de estado para cada p\u00e1gina es 200, que es la respuesta est\u00e1ndar para una solicitud HTTP exitosa. Esa es una manera elegante de garantizar que una p\u00e1gina web determinada realmente existe, pero no dice nada sobre su contenido. Para ejecutar los tests: (pages) $ python manage.py test System check identified no issues (0 silenced). .. --------------------------------------------------------------- Ran 2 tests in 0.014s OK 4.9 Git, GitHub, GitLab y Bitbucket (pages) $ git init (pages) $ git status (pages) $ git add -A (pages) $ git commit -m 'Commit inicial' (pages) $ git remote add origin git@bitbucket.org:wsvincent/pages-app.git (pages) $ git push -u origin master 4.10 Local vs Producci\u00f3n C\u00f3digo en producci\u00f3n C\u00f3digo implementado en un servidor externo para que cualquiera pueda ver el sitio web. Hay muchos proveedores de servidores disponibles, pero usaremos Heroku porque es gratis para peque\u00f1os proyectos, ampliamente utilizado y tiene un proceso de implementaci\u00f3n relativamente sencillo. 4.11 Heroku Se puede obtener una cuenta gratuita de Heroku en su sitio web . Ahora se necesita instalar la interfaz de l\u00ednea de comando (CLI) de Heroku para poder implementar desde la l\u00ednea de comando. Queremos instalar Heroku globalmente para que est\u00e9 disponible en toda nuestra computadora. Si se instala Heroku dentro de un entorno virtual, solo estar\u00e1 disponible all\u00ed. Instalar Heroku seg\u00fan el sitio web de Heroku Arch Linux Este paquete est\u00e1 mantenido por la comunidad y no por Heroku. bash $ yay -S heroku-cli (pages) $ heroku login Enter your Heroku credentials: Email: will@wsvincent.com Password: ********************************* Logged in as will@wsvincent.com 4.11 Ficheros adicionales Se necesitan hacer cuatro cambios al proyecto para desplegar en Heroku: actualizar el archivo Pipfile.lock hacer un nuevo archivo Procfile instalar gunicorn como servidor web hacer un cambio de una l\u00ednea al archivo settings.py Especificar la versi\u00f3n de Python que se est\u00e1 usando en Pipfile # Pipfile [requires] python_version = \"3.8\" Luego ejecutar pipenv lock para generar el archivo Pipfile.lock apropiado. (pages) $ pipenv lock Heroku busca en Pipfile.lock informaci\u00f3n sobre el entorno virtual. A continuaci\u00f3n crea un Procfile que es espec\u00edfico para Heroku. FICHERO: Procfile web: gunicorn pages_project.wsgi --log-file - Esto indica que se use el fichero pages_project.wsgi existente pero con gunicorn , que es un servidor web adecuado para la producci\u00f3n , en lugar del propio servidor de Django; que por otro lado a\u00fan tenemos que instalar. (pages) $ pipenv install gunicorn El \u00faltimo paso es un cambio de una l\u00ednea a settings.py . FICHERO: pages_project/settings.py # pages_project/settings.py ALLOWED_HOSTS = ['*'] El par\u00e1metro ALLOWEDHOSTS representa los nombres de host/dominio que nuestro sitio Django puede servir. Esta es una medida de seguridad para evitar los ataques de cabecera de host HTTP, que son posibles incluso bajo muchas configuraciones de servidores web aparentemente seguras. Sin embargo, se ha utilizado el comod\u00edn Asterisco \"*\", que significa que todos los dominios son aceptables para mantener las cosas simples. En un sitio Django de nivel de producci\u00f3n, se enumeran expl\u00edcitamente los dominios que est\u00e1n permitidos. Usar git status para comprobar nuestros cambios, a\u00f1adir los nuevos archivos, y luego confirmarlos: (pages) $ git status (pages) $ git add -A (pages) $ git commit -m \"Actualiza para el despliegue en Heroku\" (pages) $ git push -u origin master 4.12 Despliegue Crear una nueva aplicaci\u00f3n en Heroku y enviar el c\u00f3digo A\u00f1adir un \"hook\" remoto de git para Heroku Configurar la aplicaci\u00f3n para ignorar los archivos est\u00e1ticos Iniciar el servidor de Heroku para que la aplicaci\u00f3n est\u00e9 activa Visitar la aplicaci\u00f3n en la URL proporcionada por Heroku Crear una nueva aplicaci\u00f3n de Heroku, desde la l\u00ednea de comandos con heroku create (pages) $ heroku create Creating app... done, cryptic-oasis-40349 https://cryptic-oasis-40349.herokuapp.com/ | https://git.heroku.com/cryptic-oasis-40349.git A\u00f1adir un \u201chook\u201d para Heroku dentro de git Git almacenar\u00e1 tanto la configuraci\u00f3n para enviar el c\u00f3digo a GitHub como a Heroku. (pages) $ heroku git:remote -a cryptic-oasis-40349 Configurar la aplicaci\u00f3n para ignorar los archivos est\u00e1ticos Hay que decirle a Heroku que ignore los archivos est\u00e1ticos como CSS y JavaScript que Django por defecto intenta optimizar para nosotros (se ver\u00e1 m\u00e1s adelante). Por ahora s\u00f3lo hay que ejecutar: (pages) $ heroku config:set DISABLE_COLLECTSTATIC=1 Ahora ya podemos enviar nuestro c\u00f3digo a Heroku. (pages) $ git push heroku master Iniciar el servidor de Heroku para que la aplicaci\u00f3n est\u00e9 activa Se puede utilizar el nivel m\u00e1s bajo, web=1 , que tambi\u00e9n resulta ser gratuito. (pages) $ heroku ps:scale web=1 Visitar la aplicaci\u00f3n en la URL proporcionada por Heroku Vistiar algo como https://cryptic-oasis-40349.herokuapp.com \u00f3 https://cryptic-oasis-40349.herokuapp.com/about/. 4.13 Conclusi\u00f3n Plantillas Vistas basadas en clases URLConfs Tests b\u00e1sicos Heroku","title":"4. Pages app"},{"location":"4_pages_app/#4-pages-app","text":"","title":"4 Pages app"},{"location":"4_pages_app/#41-objetivos","text":"Desplegar la app Pages con una p\u00e1gina homepage y una about Vistas basadas en clases y plantillas (templates)","title":"4.1 Objetivos"},{"location":"4_pages_app/#42-configuracion-inicial","text":"Crear un nuevo directorio para el c\u00f3digo Instalar Django en un nuevo entorno virtual Crear un nuevo projecto Django Crear una nueva app pages Actualizar settings.py $ cd ~/Desktop $ mkdir pages $ cd pages $ pipenv install --python 3.8 $ pipenv install django $ pipenv shell (pages) $ django-admin startproject pages_project . (pages) $ python manage.py startapp pages # \u00f3 (pages) $ django-admin startproject pages FICHERO: pages_project/settings.py # pages_project/settings.py ... INSTALLED_APPS = [ \u00e7 'pages.apps.PagesConfig', ... Arrancar servidor (pages) $ python manage.py runserver","title":"4.2 Configuraci\u00f3n inicial"},{"location":"4_pages_app/#43-plantillas-templates","text":"Cada framework precisa generar de alguna manera ficheros HTML. En Django, la aproximaci\u00f3n es usar plantillas (templates) de tal forma que los archivos HTML individuales puedan ser servidos por una vista a la p\u00e1gina web especificada por la ruta (URL). Plantilla \u2013> Vista \u2013> Ruta Ruta (URL).- Controla la ruta inicial Vista (View).- Contiene la l\u00f3gica (el qu\u00e9). En p\u00e1ginas relacionadas con BD es lo que hace la mayor parte del trabajo en cuanto a decidir qu\u00e9 datos estar\u00e1n disponibles para la plantilla. Plantilla (Template).- Contiene el HTML.","title":"4.3 Plantillas (Templates)"},{"location":"4_pages_app/#431-donde-colocar-el-directorio-de-plantillas","text":"Por defecto , Django mira dentro de cada app en busca de plantillas. En la app pages se crear\u00e1 una estructura de directorios como la siguiente con la plantilla home.html colgando de ella: \u2514\u2500\u2500 pages \u251c\u2500\u2500 templates \u251c\u2500\u2500 pages \u251c\u2500\u2500 home.html La otra aproximaci\u00f3n es hacer un directorio de plantillas com\u00fan a todas las apps. Hay que cambiar settings.py para que busque, tambi\u00e9n en este directorio, las plantillas que se necesiten. (pages) $ mkdir templates (pages) $ touch templates/home.html FICHERO: pages_project/settings.py TEMPLATES = [ { ... \u00e7 'DIRS': [os.path.join(BASE_DIR, 'templates')], ... }, ] La funci\u00f3n os.path.join une el path base de la aplicaci\u00f3n ( BASE_DIR ) con el nuevo directorio templates a\u00f1adiendo / seg\u00fan sea conveniente FICHERO: templates/home.html <h1>Homepage</h1> Ahora es el turno de la ruta y la vista","title":"4.3.1 D\u00f3nde colocar el directorio de plantillas"},{"location":"4_pages_app/#44-vistas-basadas-en-clases-class-based-views","text":"Las primeras versiones de Django solo inclu\u00edan vistas basadas en funciones , pero los desarrolladores pronto se encontraron repitiendo los mismos patrones una y otra vez. Sin embargo, no hab\u00eda una manera f\u00e1cil de ampliar o personalizar estas vistas. Django introdujo vistas gen\u00e9ricas basadas en clases que facilitan el uso y tambi\u00e9n ampl\u00edan las vistas que cubren casos de uso comunes. En el ejemplo se usar\u00e1 la clase TemplateView incorporada para mostrar la plantilla. FICHERO: pages/views.py from django.views.generic import TemplateView class HomePageView(TemplateView): template_name = 'home.html' Dist\u00edngase c\u00f3mo se ha puesto en may\u00fasculas la vista, porque ahora es una clase, y c\u00f3mo \u00e9sta es descendiente de la clase base TemplateView .","title":"4.4 Vistas basadas en clases (Class-Based Views)"},{"location":"4_pages_app/#145-urls","text":"El \u00faltimo paso es actualizar los URLConfs . FICHERO: pages_project/urls.py from django.contrib import admin \u00e7 from django.urls import path, include urlpatterns = [ path('admin/', admin.site.urls), \u00e7 path('', include('pages.urls')), ] FICHERO: pages/urls.py from django.urls import path from .views import HomePageView urlpatterns = [ path('', HomePageView.as_view(), name='home'), ] Este patr\u00f3n es casi id\u00e9ntico al que se hizo anteriormente, con una sola diferencia; cuando se usan vistas basadas en clases, siempre se a\u00f1ade as_view() al final de su nombre. Iniciar el servidor para ver la nueva p\u00e1gina de inicio.","title":"1.4.5 URLs"},{"location":"4_pages_app/#46-anadir-una-pagina-acerca-de","text":"Crear un nuevo fichero de plantilla (pages) $ touch templates/about.html FICHERO: templates/about.html <h1>About page</h1> Crear una nueva vista para la p\u00e1gina FICHERO: pages/views.py from django.views.generic import TemplateView class HomePageView(TemplateView): template_name = 'home.html' class AboutPageView(TemplateView): template_name = 'about.html' Conectar la vista con la ruta FICHERO: pages/urls.py from django.urls import path \u00e7 from .views import HomePageView, AboutPageView urlpatterns = [ \u00e7 path('about/', AboutPageView.as_view(), name='about'), path('', HomePageView.as_view(), name='home'), ] Lanzar http://localhost:8000/about","title":"4.6 A\u00f1adir una p\u00e1gina \"Acerca de...\""},{"location":"4_pages_app/#47-extending-templates","text":"El poder real de las plantillas es la posibilidad de ser extendidas. En las mayor\u00eda de webs encontramos contenido que se repite en cada p\u00e1gina: Hagamos una p\u00e1gina can\u00f3nica que ser\u00e1 heredada por las dem\u00e1s Django tiene un lenguaje m\u00ednimo de plantillas para a\u00f1adirles enlaces y l\u00f3gica b\u00e1sica Los tags de las plantillas tienen la forma {%&ltcualquier cosa&gt%} Para a\u00f1adir enlaces a nuestro proyecto podemos usar la etiqueta de plantilla url incorporada que toma un patr\u00f3n de URL como argumento. El tag url utiliza los nombres opcionales de URL para crear enlaces autom\u00e1ticos por nosotros. Por ejemplo: {% url 'home' %} FICHERO: templates/base.html <header> <a href=\"{% url 'home' %}\">Home</a> | <a href=\"{% url 'about' %}\">About</a> </header> {% block content %} {% endblock content %} Al final se a\u00f1ade un tag block llamado content . Los bloques pueden ser reescritos por las vistas descencientes. El lenguaje de plantillas de Django dispone de un m\u00e9todo extends que puede usarse para actualizar home.html y about.html y as\u00ed extender la plantilla base.html . FICHERO: templates/home.html {% extends 'base.html' %} {% block content %} <h1>Homepage</h1> {% endblock content %} FICHERO: templates/about.html {% extends 'base.html' %} {% block content %} <h1>About page</h1> {% endblock content %}","title":"4.7 Extending Templates"},{"location":"4_pages_app/#48-tests","text":"Importancia de los tests Jaco Kaplan-Moss : \"Code without tests is broken as designed.\" (El c\u00f3digo sin pruebas se rompe seg\u00fan se dise\u00f1\u00f3) Django nos brinda herramientas para escribir y correr tests. FICHERO: pages/tests.py \u00e7 from django.test import SimpleTestCase \u00e7 class SimpleTests(SimpleTestCase): \u00e7 def test_home_page_status_code(self): \u00e7 response = self.client.get('/') \u00e7 self.assertEqual(response.status_code, 200) \u00e7 def test_about_page_status_code(self): \u00e7 response = self.client.get('/about/') \u00e7 self.assertEqual(response.status_code, 200) Se usa SimpleTestCase ya que no estamos usando una base de datos. Si estuvi\u00e9ramos usando una base de datos, en su lugar usar\u00edamos TestCase . Luego se realiza una comprobaci\u00f3n de si el c\u00f3digo de estado para cada p\u00e1gina es 200, que es la respuesta est\u00e1ndar para una solicitud HTTP exitosa. Esa es una manera elegante de garantizar que una p\u00e1gina web determinada realmente existe, pero no dice nada sobre su contenido. Para ejecutar los tests: (pages) $ python manage.py test System check identified no issues (0 silenced). .. --------------------------------------------------------------- Ran 2 tests in 0.014s OK","title":"4.8 Tests"},{"location":"4_pages_app/#49-git-github-gitlab-y-bitbucket","text":"(pages) $ git init (pages) $ git status (pages) $ git add -A (pages) $ git commit -m 'Commit inicial' (pages) $ git remote add origin git@bitbucket.org:wsvincent/pages-app.git (pages) $ git push -u origin master","title":"4.9 Git, GitHub, GitLab y Bitbucket"},{"location":"4_pages_app/#410-local-vs-produccion","text":"C\u00f3digo en producci\u00f3n C\u00f3digo implementado en un servidor externo para que cualquiera pueda ver el sitio web. Hay muchos proveedores de servidores disponibles, pero usaremos Heroku porque es gratis para peque\u00f1os proyectos, ampliamente utilizado y tiene un proceso de implementaci\u00f3n relativamente sencillo.","title":"4.10 Local vs Producci\u00f3n"},{"location":"4_pages_app/#411-heroku","text":"Se puede obtener una cuenta gratuita de Heroku en su sitio web . Ahora se necesita instalar la interfaz de l\u00ednea de comando (CLI) de Heroku para poder implementar desde la l\u00ednea de comando. Queremos instalar Heroku globalmente para que est\u00e9 disponible en toda nuestra computadora. Si se instala Heroku dentro de un entorno virtual, solo estar\u00e1 disponible all\u00ed. Instalar Heroku seg\u00fan el sitio web de Heroku Arch Linux Este paquete est\u00e1 mantenido por la comunidad y no por Heroku. bash $ yay -S heroku-cli (pages) $ heroku login Enter your Heroku credentials: Email: will@wsvincent.com Password: ********************************* Logged in as will@wsvincent.com","title":"4.11 Heroku"},{"location":"4_pages_app/#411-ficheros-adicionales","text":"Se necesitan hacer cuatro cambios al proyecto para desplegar en Heroku: actualizar el archivo Pipfile.lock hacer un nuevo archivo Procfile instalar gunicorn como servidor web hacer un cambio de una l\u00ednea al archivo settings.py Especificar la versi\u00f3n de Python que se est\u00e1 usando en Pipfile # Pipfile [requires] python_version = \"3.8\" Luego ejecutar pipenv lock para generar el archivo Pipfile.lock apropiado. (pages) $ pipenv lock Heroku busca en Pipfile.lock informaci\u00f3n sobre el entorno virtual. A continuaci\u00f3n crea un Procfile que es espec\u00edfico para Heroku. FICHERO: Procfile web: gunicorn pages_project.wsgi --log-file - Esto indica que se use el fichero pages_project.wsgi existente pero con gunicorn , que es un servidor web adecuado para la producci\u00f3n , en lugar del propio servidor de Django; que por otro lado a\u00fan tenemos que instalar. (pages) $ pipenv install gunicorn El \u00faltimo paso es un cambio de una l\u00ednea a settings.py . FICHERO: pages_project/settings.py # pages_project/settings.py ALLOWED_HOSTS = ['*'] El par\u00e1metro ALLOWEDHOSTS representa los nombres de host/dominio que nuestro sitio Django puede servir. Esta es una medida de seguridad para evitar los ataques de cabecera de host HTTP, que son posibles incluso bajo muchas configuraciones de servidores web aparentemente seguras. Sin embargo, se ha utilizado el comod\u00edn Asterisco \"*\", que significa que todos los dominios son aceptables para mantener las cosas simples. En un sitio Django de nivel de producci\u00f3n, se enumeran expl\u00edcitamente los dominios que est\u00e1n permitidos. Usar git status para comprobar nuestros cambios, a\u00f1adir los nuevos archivos, y luego confirmarlos: (pages) $ git status (pages) $ git add -A (pages) $ git commit -m \"Actualiza para el despliegue en Heroku\" (pages) $ git push -u origin master","title":"4.11 Ficheros adicionales"},{"location":"4_pages_app/#412-despliegue","text":"Crear una nueva aplicaci\u00f3n en Heroku y enviar el c\u00f3digo A\u00f1adir un \"hook\" remoto de git para Heroku Configurar la aplicaci\u00f3n para ignorar los archivos est\u00e1ticos Iniciar el servidor de Heroku para que la aplicaci\u00f3n est\u00e9 activa Visitar la aplicaci\u00f3n en la URL proporcionada por Heroku","title":"4.12 Despliegue"},{"location":"4_pages_app/#crear-una-nueva-aplicacion-de-heroku-desde-la-linea-de-comandos-con-heroku-create","text":"(pages) $ heroku create Creating app... done, cryptic-oasis-40349 https://cryptic-oasis-40349.herokuapp.com/ | https://git.heroku.com/cryptic-oasis-40349.git","title":"Crear una nueva aplicaci\u00f3n de Heroku, desde la l\u00ednea de comandos con heroku create"},{"location":"4_pages_app/#anadir-un-hook-para-heroku-dentro-de-git","text":"Git almacenar\u00e1 tanto la configuraci\u00f3n para enviar el c\u00f3digo a GitHub como a Heroku. (pages) $ heroku git:remote -a cryptic-oasis-40349","title":"A\u00f1adir un \u201chook\u201d para Heroku dentro de git"},{"location":"4_pages_app/#configurar-la-aplicacion-para-ignorar-los-archivos-estaticos","text":"Hay que decirle a Heroku que ignore los archivos est\u00e1ticos como CSS y JavaScript que Django por defecto intenta optimizar para nosotros (se ver\u00e1 m\u00e1s adelante). Por ahora s\u00f3lo hay que ejecutar: (pages) $ heroku config:set DISABLE_COLLECTSTATIC=1 Ahora ya podemos enviar nuestro c\u00f3digo a Heroku. (pages) $ git push heroku master","title":"Configurar la aplicaci\u00f3n para ignorar los archivos est\u00e1ticos"},{"location":"4_pages_app/#iniciar-el-servidor-de-heroku-para-que-la-aplicacion-este-activa","text":"Se puede utilizar el nivel m\u00e1s bajo, web=1 , que tambi\u00e9n resulta ser gratuito. (pages) $ heroku ps:scale web=1","title":"Iniciar el servidor de Heroku para que la aplicaci\u00f3n est\u00e9 activa"},{"location":"4_pages_app/#visitar-la-aplicacion-en-la-url-proporcionada-por-heroku","text":"Vistiar algo como https://cryptic-oasis-40349.herokuapp.com \u00f3 https://cryptic-oasis-40349.herokuapp.com/about/.","title":"Visitar la aplicaci\u00f3n en la URL proporcionada por Heroku"},{"location":"4_pages_app/#413-conclusion","text":"Plantillas Vistas basadas en clases URLConfs Tests b\u00e1sicos Heroku","title":"4.13 Conclusi\u00f3n"},{"location":"5_message_board_app/","text":"Message Board app Aplicaci\u00f3n en la que los usuarios pueden publicar y leer mensajes cortos con la ayuda de una base de datos. Se explorar\u00e1 la interfaz de administraci\u00f3n incorporada de Django Se agregar\u00e1n pruebas Se subir\u00e1 a github y se desplegar\u00e1 en Heroku Django proporciona soporte incorporado para varios tipos de backends de bases de datos Se empezar\u00e1 con SQLite Se ejecuta a partir de un \u00fanico archivo No requiere una instalaci\u00f3n compleja Es una elecci\u00f3n perfecta para proyectos peque\u00f1os. Setup Inicial Crear un nuevo directorio para nuestro c\u00f3digo en el Escritorio llamado mb Instalar Django en un nuevo entorno virtual Crear un nuevo proyecto llamado mb_project Crear una nueva aplicaci\u00f3n posts Actualizar settings.py $ cd ~/Desktop $ mkdir mb $ cd mb $ pipenv install django $ pipenv shell (mb) $ django-admin startproject mb_project . (mb) $ python manage.py startapp posts FICHERO: mb_project/settings.py # mb_project/settings.py INSTALL_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', \u00e7 'posts', ] A continuaci\u00f3n, ejecutar el comando migrate para crear una base de datos inicial basada en la configuraci\u00f3n por defecto de Django. (mb) $ python manage.py migrate Ahora en el directorio habr\u00e1 ahora un fichero db.sqlite3 que representa a la base de datos SQLite. (mb) $ ls db.sqlite3 mb_project manage.py Nota .- T\u00e9cnicamente se crea un fichero db.sqlite3 la primera vez que se ejecuta una migraci\u00f3n ( migrate ) o se ejecuta el servidor ( runserver ). El uso de runserver configura una base de datos utilizando la configuraci\u00f3n predeterminada de Django, sin embargo, la migraci\u00f3n sincronizar\u00e1 la base de datos con el estado actual de cualquier modelo de base de datos contenido en el proyecto y listado en INSTALLED_APPS . En otras palabras, para asegurar que la base de datos refleja el estado actual del proyecto se tendr\u00e1 que ejecutar migrate (y tambi\u00e9n makemigrations ) cada vez que se actualiza un modelo. M\u00e1s en breve. Lanzar el servidor local y comprobar el funcionamiento (mb) $ python manage.py runserver Crear un modelo de base de datos Crear un modelo de base de datos donde se pueda almacenar y mostrar los mensajes de los usuarios. Django convertir\u00e1 este modelo en una tabla de base de datos. FICHERO: posts/models.py # posts/models.py from django.db import models # Create your models here Django importa un m\u00f3dulo models para ayudarnos a construir nuevos modelos de bases de datos, que \"modelan\" las caracter\u00edsticas de los datos de la base de datos. - Se quiere crear un modelo para almacenar el contenido textual de un mensaje en el tablero de mensajes, lo cual podemos hacer de la siguiente manera: FICHERO: post/models.py # posts/models.py from django.db import models class Post(models.Model): text = models.TextField() Se ha creado un nuevo modelo de base de datos llamado Post que tiene el campo text de tipo TextField() . Activando modelos Una vez creado, el modelo tiene que ser activado Primero se crea un archivo de migraci\u00f3n con el comando makemigrations que genera los comandos SQL para las aplicaciones preinstaladas en nuestra configuraci\u00f3n de INSTALLED_APPS. Los archivos de migraci\u00f3n no ejecutan esos comandos en el archivo de base de datos, sino que son una referencia de todos los cambios en los modelos. Este enfoque significa que tienen un registro de los cambios de los modelos a lo largo del tiempo. En segundo lugar, construimos la base de datos actual con migrate que ejecuta la funci\u00f3n en el archivo de migraciones. (mb) $ python manage.py makemigrations posts (mb) $ python manage.py migrate posts No es necesario incluir un nombre despu\u00e9s de makemigrations o de migrate pero es un buen h\u00e1bito para ser espec\u00edfico. Si tenemos dos aplicaciones separadas en nuestro proyecto, se actualizan los modelos en ambos y luego se ejecuta makemigrations se generer\u00e1 un archivo de migraciones que contiene datos sobre ambas modificaciones. Esto hace que la depuraci\u00f3n sea m\u00e1s dif\u00edcil en el futuro. Es deseable que cada archivo de migraci\u00f3n sea lo m\u00e1s peque\u00f1o y aislado posible. De esta forma, si se necesita mirar las migraciones pasadas, s\u00f3lo hay un cambio por migraci\u00f3n en lugar de uno que se aplica a m\u00faltiples aplicaciones. Django Admin Django proporciona una robusta interfaz de administraci\u00f3n para interactuar con la base de datos (pocos frameworks ofrecen tal cosa). Originado como proyecto en un peri\u00f3dico, los desarrolladores quer\u00edan un CMS para que los periodistas pudieran escribir y editar sus historias sin tocar \"c\u00f3digo\". Para utilizar el administrador de Django, primero necesitamos crear un superusuario que pueda iniciar sesi\u00f3n. (mb) $ python manage.py createsuperuser Username (leave blank to use 'wsv'): wsv Email: Password: Password (again): Superuser created successfully. Reiniciar el servidor Django con python manage.py y en el navegador ir a http://127.0.0.1:8000/admin/. Necesitamos decirle expl\u00edcitamente a Django qu\u00e9 mostrar en la p\u00e1gina de administraci\u00f3n. FICHERO: post/admin.py # posts/admin.py from django.contrib import admin from .models import Post admin.site.register(Post) Ahora crear el primer mensaje en el tablero de mensajes. Problema : La nueva entrada se llama \u201cPost object\u201d, lo cual no es muy \u00fatil Cambiamos eso a\u00f1adiendo una nueva funci\u00f3n __str__ como sigue: FICHERO: posts/models.py # posts/models.py from django.db import models class Post(models.Model): text = models.TextField() \u00e7 def __str__(self): \u00e7 \"\"\"A string representation of the model.\"\"\" \u00e7 return self.text[:50] Es una buena pr\u00e1ctica a\u00f1adir m\u00e9todos str() a todos los modelos para aumentar la legibilidad. Views/Templates/URLs Para poder mostrar el contenido de la base de datos en la web, hay que conectar las vistas , las plantillas y las URLConfs . Vista Django viene equipado con el ListView gen\u00e9rico basado en clases. FICHERO: posts/views.py # posts/views.py from django.views.generic import ListView from .models import Post class HomePageView(ListView): model = Post template_name = 'home.html' Importar ListView Definir qu\u00e9 modelo se va a usar En la vista, se deriva la clase ListView para especificar el nombre del modelo y la referencia de la plantilla. Internamente ListView devuelve un ojeto llamado object_list que hay que mostrar en la plantilla. Plantilla Crear un directorio en el nivel del proyecto que se llame templates y una plantilla home.html en \u00e9l (mb) $ mkdir templates (mb) $ touch templates/home.html Actualizar el campo DIRS del archivo settings.py para que Django sepa c\u00f3mo acceder a la carpeta templates . # settings.py TEMPLATES = [ { ... 'DIRS': [os.path.join(BASE_DIR, 'templates')], ... }, ] En el archivo home.html se puede usar bucle for del lenguaje de plantillas de Django para listar todos los objetos en object_list . FICHERO: templates/home.html <!-- templates/home.html --> <h1>Message board homepage</h1> <ul> {% for post in object_list %} <li>{{ post }}</li> {% endfor %} </ul> URLConfs FICHERO: mb_project/urls.py # mb_project/urls.py from django.contrib import admin \u00e7 from django.urls import path, include urlpatterns = [ path('admin/', admin.site.urls), \u00e7 path('', include('posts.urls')), ] Crear el fichero urls.py a nivel de app (mb) $ touch posts/urls.py ...con el siguiente contenido: FICHERO: posts/urls.py \u00e7 # posts/urls.py \u00e7 from django.urls import path \u00e7 from . import views \u00e7 urlpatterns = [ \u00e7 path('', views.HomePageView.as_view(), name='home'), \u00e7 ] Reiniciar el servidor que ahora mostrar\u00e1 los post del tabl\u00f3n de mensajes A\u00f1\u00e1danse m\u00e1s posts ;-) No olvidar (mb) $ git init (mb) $ git add -A (mb) $ git commit -m 'Realiza el commit inicial' Tests Se necesita usar TestCase dado que ahora tenemos una base de datos y no solo una p\u00e1gina est\u00e1tica. Se crear\u00e1 una base de datos con la que se pueden hacer pruebas (no se hacen con la base de datos real). Se empezar\u00e1 a\u00f1adiendo un mensaje de muestra al campo de la base de datos de texto para luego comprobar que se almacena correctamente. Es importante que todos los m\u00e9todos de prueba comiencen con test_ para que Django sepa c\u00f3mo manejarlos FICHERO: posts/test.py # posts/tests.py from django.test import TestCase \u00e7 from .models import Post \u00e7 class PostModelTest(TestCase): \u00e7 def setUp(self): \u00e7 Post.objects.create(text='just a test') \u00e7 def test_text_content(self): \u00e7 post=Post.objects.get(id=1) \u00e7 expected_object_name = f'{post.text}' \u00e7 self.assertEqual(expected_object_name, 'just a test') Importa el m\u00f3dulo TestCase que permite crear una base de datos de muestra Importa el modelo Post Se crea una nueva clase PostModelTest y se le a\u00f1ade un m\u00e9todo setUp para crear una nueva base de datos con una sola entrada: \"just a test\" Ejecutar test_text_content , para comprobar que el campo de la base de datos realmente contiene just a test . Se crea una variable llamada post que representa el primer id en el modelo de Post. Django asigna autom\u00e1ticamente esta identificaci\u00f3n La siguiente l\u00ednea usa \"cadenas f\", que son una adici\u00f3n muy interesante desde Python 3.6, y permiten poner variables directamente en las cadenas siempre y cuando est\u00e9n rodeadas de corchetes {} Se establece expected_object_name como el valor de la cadena en post.text que permitir\u00e1 hacer la prueba En la \u00faltima l\u00ednea se usa assertEqual para comprobar que la entrada reci\u00e9n creada coincide con la dispuesta al principio Ejecutar la prueba con python manage.py test (mb) $ python manage.py test Creating test database for alias 'default'... System check identified no issues (0 silenced). . --------------------------------------------------------------- Ran 1 test in 0.001s OK Destroying test database for alias 'default'... A pesar de lo aparentemente complicado del asunto pronto se ver\u00e1 que en la mayor parte de los casos, los tests son repetitivos El segundo test comprueba una sola p\u00e1gina: la homepage. En concreto que exista (lanza una respuesta HTTP 200). Usa la vista home y la plantilla home.html . Se necesita a\u00f1adir un import m\u00e1s para reverse y una nueva clase HomePageViewTest from django.test import TestCase \u00e7 from django.urls import reverse from .models import Post class PostModelTest(TestCase): def setUp(self): Post.objects.create(text='just a test') def test_text_content(self): post=Post.objects.get(id=1) expected_object_name = f'{post.text}' self.assertEqual(expected_object_name, 'just a test') \u00e7 class HomePageViewTest(TestCase): \u00e7 def setUp(self): \u00e7 Post.objects.create(text='this is another test') \u00e7 def test_view_url_exists_at_proper_location(self): \u00e7 resp = self.client.get('/') \u00e7 self.assertEqual(resp.status_code, 200) \u00e7 def test_view_url_by_name(self): \u00e7 resp = self.client.get(reverse('home')) \u00e7 self.assertEqual(resp.status_code, 200) \u00e7 def test_view_uses_correct_template(self): \u00e7 resp = self.client.get(reverse('home')) \u00e7 self.assertEqual(resp.status_code, 200) \u00e7 self.assertTemplateUsed(resp, 'home.html') Ejecutando el test: (mb) $ python manage.py test Creating test database for alias 'default'... System check identified no issues (0 silenced). . ---------------------------------------------------------------------- Ran 4 tests in 0.036s OK Destroying test database for alias 'default'... 4 test: test_text_content , test_view_url_exists_at_proper_location , test_view_url_by_name y test_view_uses_correct_template . Cualquier funci\u00f3n que tenga la palabra test* al principio y exista en un fichero tests.py se lanzar\u00e1 cuando se ejecuta el comando python manage.py test . Hora de hacer commit de los cambios. (mb) $ git add -A (mb) $ git commit -m 'added tests' GitHub Subir el proyecto... Heroku configuration Hay que hacer los siguientes cambios al projecto para desplegarlo online: Actualizar Pipfile.lock Crear Procfile Instalar gunicorn Actualizar settings.py Actualizar Pipfile.lock Especificar la versi\u00f3n de python que se est\u00e1 usando FICHERO: Pipfile # Pipfile [requires] python_version = \"3.8\" Ejecutar pipenv lock para generar el Pipfile.lock adecuado. (mb) $ pipenv lock Crear Procfile Le dir\u00e1 a Heroku c\u00f3mo ejecutar el servidor remoto donde habita el c\u00f3digo. (mb) $ touch Procfile Instalar gunicorn Por ahora Heroku usa gunicorn como servidor de producci\u00f3n y mira en el fichero mb_project.wsgi para m\u00e1s instrucciones. web: gunicorn mb_project.wsgi --log-file - Luego, se instala gunicorn , que se usar\u00e1 en producci\u00f3n mientras se siga usando el servidor interno de Django para desarrollo local. (mb) $ pipenv install gunicorn Actualizar settings.py Actualizar ALLOWED_HOSTS en el archivo settings.py . FICHERO: mb_project/settings.py # mb_project/settings.py ALLOWED_HOSTS = ['*'] commit y push (mb) $ git status (mb) $ git add -A (mb) $ git commit -m 'New updates for Heroku deployment' (mb) $ git push -u origin master Despliegue en Heroku Login (mb) $ heroku login Create .- Genera un nombre aleatorio para la aplicaci\u00f3n (mb) $ heroku create Creating app... done,agile-inlet-25811 https://agile-inlet-25811.herokuapp.com/ | https://git.heroku.com/agile-inlet-25811.git Establecer a git para usar el nombre de la nueva aplicaci\u00f3n cuando se suba el c\u00f3digo a Heroku. (mb) $ heroku git:remote -a agile-inlet-25811 Indicar a que ignore los archivos est\u00e1ticos (se tratar\u00e1 m\u00e1s adelante). (mb) $ heroku config:set DISABLE_COLLECTSTATIC=1 Subir el c\u00f3digo a Heroku y a\u00f1adir escalado gratuito para que se ejecute realmente en l\u00ednea, de lo contrario el c\u00f3digo s\u00f3lo se quedar\u00e1 alojado. (mb) $ git push heroku master (mb) $ heroku ps:scale web=1 Abrir el c\u00f3digo con heroku open y autom\u00e1ticamente mostrar\u00e1 un navegador con la URL de la aplicaci\u00f3n. Conclusi\u00f3n Se ha construido, probado e implementado la primera aplicaci\u00f3n b\u00e1sica basada en una base de datos. Faltar\u00edan formularios para interactuar con el sitio (el panel de administraci\u00f3n no es lo adecuado). Se crear\u00e1 una aplicaci\u00f3n de blog con formularios para que los usuarios puedan crear, editar y borrar mensajes. Se le a\u00f1adir\u00e1 estilo a trav\u00e9s de CSS.","title":"5. Message Board app"},{"location":"5_message_board_app/#message-board-app","text":"Aplicaci\u00f3n en la que los usuarios pueden publicar y leer mensajes cortos con la ayuda de una base de datos. Se explorar\u00e1 la interfaz de administraci\u00f3n incorporada de Django Se agregar\u00e1n pruebas Se subir\u00e1 a github y se desplegar\u00e1 en Heroku Django proporciona soporte incorporado para varios tipos de backends de bases de datos Se empezar\u00e1 con SQLite Se ejecuta a partir de un \u00fanico archivo No requiere una instalaci\u00f3n compleja Es una elecci\u00f3n perfecta para proyectos peque\u00f1os.","title":"Message Board app"},{"location":"5_message_board_app/#setup-inicial","text":"Crear un nuevo directorio para nuestro c\u00f3digo en el Escritorio llamado mb Instalar Django en un nuevo entorno virtual Crear un nuevo proyecto llamado mb_project Crear una nueva aplicaci\u00f3n posts Actualizar settings.py $ cd ~/Desktop $ mkdir mb $ cd mb $ pipenv install django $ pipenv shell (mb) $ django-admin startproject mb_project . (mb) $ python manage.py startapp posts FICHERO: mb_project/settings.py # mb_project/settings.py INSTALL_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', \u00e7 'posts', ] A continuaci\u00f3n, ejecutar el comando migrate para crear una base de datos inicial basada en la configuraci\u00f3n por defecto de Django. (mb) $ python manage.py migrate Ahora en el directorio habr\u00e1 ahora un fichero db.sqlite3 que representa a la base de datos SQLite. (mb) $ ls db.sqlite3 mb_project manage.py Nota .- T\u00e9cnicamente se crea un fichero db.sqlite3 la primera vez que se ejecuta una migraci\u00f3n ( migrate ) o se ejecuta el servidor ( runserver ). El uso de runserver configura una base de datos utilizando la configuraci\u00f3n predeterminada de Django, sin embargo, la migraci\u00f3n sincronizar\u00e1 la base de datos con el estado actual de cualquier modelo de base de datos contenido en el proyecto y listado en INSTALLED_APPS . En otras palabras, para asegurar que la base de datos refleja el estado actual del proyecto se tendr\u00e1 que ejecutar migrate (y tambi\u00e9n makemigrations ) cada vez que se actualiza un modelo. M\u00e1s en breve. Lanzar el servidor local y comprobar el funcionamiento (mb) $ python manage.py runserver","title":"Setup Inicial"},{"location":"5_message_board_app/#crear-un-modelo-de-base-de-datos","text":"Crear un modelo de base de datos donde se pueda almacenar y mostrar los mensajes de los usuarios. Django convertir\u00e1 este modelo en una tabla de base de datos. FICHERO: posts/models.py # posts/models.py from django.db import models # Create your models here Django importa un m\u00f3dulo models para ayudarnos a construir nuevos modelos de bases de datos, que \"modelan\" las caracter\u00edsticas de los datos de la base de datos. - Se quiere crear un modelo para almacenar el contenido textual de un mensaje en el tablero de mensajes, lo cual podemos hacer de la siguiente manera: FICHERO: post/models.py # posts/models.py from django.db import models class Post(models.Model): text = models.TextField() Se ha creado un nuevo modelo de base de datos llamado Post que tiene el campo text de tipo TextField() .","title":"Crear un modelo de base de datos"},{"location":"5_message_board_app/#activando-modelos","text":"Una vez creado, el modelo tiene que ser activado Primero se crea un archivo de migraci\u00f3n con el comando makemigrations que genera los comandos SQL para las aplicaciones preinstaladas en nuestra configuraci\u00f3n de INSTALLED_APPS. Los archivos de migraci\u00f3n no ejecutan esos comandos en el archivo de base de datos, sino que son una referencia de todos los cambios en los modelos. Este enfoque significa que tienen un registro de los cambios de los modelos a lo largo del tiempo. En segundo lugar, construimos la base de datos actual con migrate que ejecuta la funci\u00f3n en el archivo de migraciones. (mb) $ python manage.py makemigrations posts (mb) $ python manage.py migrate posts No es necesario incluir un nombre despu\u00e9s de makemigrations o de migrate pero es un buen h\u00e1bito para ser espec\u00edfico. Si tenemos dos aplicaciones separadas en nuestro proyecto, se actualizan los modelos en ambos y luego se ejecuta makemigrations se generer\u00e1 un archivo de migraciones que contiene datos sobre ambas modificaciones. Esto hace que la depuraci\u00f3n sea m\u00e1s dif\u00edcil en el futuro. Es deseable que cada archivo de migraci\u00f3n sea lo m\u00e1s peque\u00f1o y aislado posible. De esta forma, si se necesita mirar las migraciones pasadas, s\u00f3lo hay un cambio por migraci\u00f3n en lugar de uno que se aplica a m\u00faltiples aplicaciones.","title":"Activando modelos"},{"location":"5_message_board_app/#django-admin","text":"Django proporciona una robusta interfaz de administraci\u00f3n para interactuar con la base de datos (pocos frameworks ofrecen tal cosa). Originado como proyecto en un peri\u00f3dico, los desarrolladores quer\u00edan un CMS para que los periodistas pudieran escribir y editar sus historias sin tocar \"c\u00f3digo\". Para utilizar el administrador de Django, primero necesitamos crear un superusuario que pueda iniciar sesi\u00f3n. (mb) $ python manage.py createsuperuser Username (leave blank to use 'wsv'): wsv Email: Password: Password (again): Superuser created successfully. Reiniciar el servidor Django con python manage.py y en el navegador ir a http://127.0.0.1:8000/admin/. Necesitamos decirle expl\u00edcitamente a Django qu\u00e9 mostrar en la p\u00e1gina de administraci\u00f3n. FICHERO: post/admin.py # posts/admin.py from django.contrib import admin from .models import Post admin.site.register(Post) Ahora crear el primer mensaje en el tablero de mensajes. Problema : La nueva entrada se llama \u201cPost object\u201d, lo cual no es muy \u00fatil Cambiamos eso a\u00f1adiendo una nueva funci\u00f3n __str__ como sigue: FICHERO: posts/models.py # posts/models.py from django.db import models class Post(models.Model): text = models.TextField() \u00e7 def __str__(self): \u00e7 \"\"\"A string representation of the model.\"\"\" \u00e7 return self.text[:50] Es una buena pr\u00e1ctica a\u00f1adir m\u00e9todos str() a todos los modelos para aumentar la legibilidad.","title":"Django Admin"},{"location":"5_message_board_app/#viewstemplatesurls","text":"Para poder mostrar el contenido de la base de datos en la web, hay que conectar las vistas , las plantillas y las URLConfs .","title":"Views/Templates/URLs"},{"location":"5_message_board_app/#vista","text":"Django viene equipado con el ListView gen\u00e9rico basado en clases. FICHERO: posts/views.py # posts/views.py from django.views.generic import ListView from .models import Post class HomePageView(ListView): model = Post template_name = 'home.html' Importar ListView Definir qu\u00e9 modelo se va a usar En la vista, se deriva la clase ListView para especificar el nombre del modelo y la referencia de la plantilla. Internamente ListView devuelve un ojeto llamado object_list que hay que mostrar en la plantilla.","title":"Vista"},{"location":"5_message_board_app/#plantilla","text":"Crear un directorio en el nivel del proyecto que se llame templates y una plantilla home.html en \u00e9l (mb) $ mkdir templates (mb) $ touch templates/home.html Actualizar el campo DIRS del archivo settings.py para que Django sepa c\u00f3mo acceder a la carpeta templates . # settings.py TEMPLATES = [ { ... 'DIRS': [os.path.join(BASE_DIR, 'templates')], ... }, ] En el archivo home.html se puede usar bucle for del lenguaje de plantillas de Django para listar todos los objetos en object_list . FICHERO: templates/home.html <!-- templates/home.html --> <h1>Message board homepage</h1> <ul> {% for post in object_list %} <li>{{ post }}</li> {% endfor %} </ul>","title":"Plantilla"},{"location":"5_message_board_app/#urlconfs","text":"FICHERO: mb_project/urls.py # mb_project/urls.py from django.contrib import admin \u00e7 from django.urls import path, include urlpatterns = [ path('admin/', admin.site.urls), \u00e7 path('', include('posts.urls')), ] Crear el fichero urls.py a nivel de app (mb) $ touch posts/urls.py ...con el siguiente contenido: FICHERO: posts/urls.py \u00e7 # posts/urls.py \u00e7 from django.urls import path \u00e7 from . import views \u00e7 urlpatterns = [ \u00e7 path('', views.HomePageView.as_view(), name='home'), \u00e7 ] Reiniciar el servidor que ahora mostrar\u00e1 los post del tabl\u00f3n de mensajes A\u00f1\u00e1danse m\u00e1s posts ;-) No olvidar (mb) $ git init (mb) $ git add -A (mb) $ git commit -m 'Realiza el commit inicial'","title":"URLConfs"},{"location":"5_message_board_app/#tests","text":"Se necesita usar TestCase dado que ahora tenemos una base de datos y no solo una p\u00e1gina est\u00e1tica. Se crear\u00e1 una base de datos con la que se pueden hacer pruebas (no se hacen con la base de datos real). Se empezar\u00e1 a\u00f1adiendo un mensaje de muestra al campo de la base de datos de texto para luego comprobar que se almacena correctamente. Es importante que todos los m\u00e9todos de prueba comiencen con test_ para que Django sepa c\u00f3mo manejarlos FICHERO: posts/test.py # posts/tests.py from django.test import TestCase \u00e7 from .models import Post \u00e7 class PostModelTest(TestCase): \u00e7 def setUp(self): \u00e7 Post.objects.create(text='just a test') \u00e7 def test_text_content(self): \u00e7 post=Post.objects.get(id=1) \u00e7 expected_object_name = f'{post.text}' \u00e7 self.assertEqual(expected_object_name, 'just a test') Importa el m\u00f3dulo TestCase que permite crear una base de datos de muestra Importa el modelo Post Se crea una nueva clase PostModelTest y se le a\u00f1ade un m\u00e9todo setUp para crear una nueva base de datos con una sola entrada: \"just a test\" Ejecutar test_text_content , para comprobar que el campo de la base de datos realmente contiene just a test . Se crea una variable llamada post que representa el primer id en el modelo de Post. Django asigna autom\u00e1ticamente esta identificaci\u00f3n La siguiente l\u00ednea usa \"cadenas f\", que son una adici\u00f3n muy interesante desde Python 3.6, y permiten poner variables directamente en las cadenas siempre y cuando est\u00e9n rodeadas de corchetes {} Se establece expected_object_name como el valor de la cadena en post.text que permitir\u00e1 hacer la prueba En la \u00faltima l\u00ednea se usa assertEqual para comprobar que la entrada reci\u00e9n creada coincide con la dispuesta al principio Ejecutar la prueba con python manage.py test (mb) $ python manage.py test Creating test database for alias 'default'... System check identified no issues (0 silenced). . --------------------------------------------------------------- Ran 1 test in 0.001s OK Destroying test database for alias 'default'... A pesar de lo aparentemente complicado del asunto pronto se ver\u00e1 que en la mayor parte de los casos, los tests son repetitivos El segundo test comprueba una sola p\u00e1gina: la homepage. En concreto que exista (lanza una respuesta HTTP 200). Usa la vista home y la plantilla home.html . Se necesita a\u00f1adir un import m\u00e1s para reverse y una nueva clase HomePageViewTest from django.test import TestCase \u00e7 from django.urls import reverse from .models import Post class PostModelTest(TestCase): def setUp(self): Post.objects.create(text='just a test') def test_text_content(self): post=Post.objects.get(id=1) expected_object_name = f'{post.text}' self.assertEqual(expected_object_name, 'just a test') \u00e7 class HomePageViewTest(TestCase): \u00e7 def setUp(self): \u00e7 Post.objects.create(text='this is another test') \u00e7 def test_view_url_exists_at_proper_location(self): \u00e7 resp = self.client.get('/') \u00e7 self.assertEqual(resp.status_code, 200) \u00e7 def test_view_url_by_name(self): \u00e7 resp = self.client.get(reverse('home')) \u00e7 self.assertEqual(resp.status_code, 200) \u00e7 def test_view_uses_correct_template(self): \u00e7 resp = self.client.get(reverse('home')) \u00e7 self.assertEqual(resp.status_code, 200) \u00e7 self.assertTemplateUsed(resp, 'home.html') Ejecutando el test: (mb) $ python manage.py test Creating test database for alias 'default'... System check identified no issues (0 silenced). . ---------------------------------------------------------------------- Ran 4 tests in 0.036s OK Destroying test database for alias 'default'... 4 test: test_text_content , test_view_url_exists_at_proper_location , test_view_url_by_name y test_view_uses_correct_template . Cualquier funci\u00f3n que tenga la palabra test* al principio y exista en un fichero tests.py se lanzar\u00e1 cuando se ejecuta el comando python manage.py test . Hora de hacer commit de los cambios. (mb) $ git add -A (mb) $ git commit -m 'added tests'","title":"Tests"},{"location":"5_message_board_app/#github","text":"Subir el proyecto...","title":"GitHub"},{"location":"5_message_board_app/#heroku-configuration","text":"Hay que hacer los siguientes cambios al projecto para desplegarlo online: Actualizar Pipfile.lock Crear Procfile Instalar gunicorn Actualizar settings.py","title":"Heroku configuration"},{"location":"5_message_board_app/#actualizar-pipfilelock","text":"Especificar la versi\u00f3n de python que se est\u00e1 usando FICHERO: Pipfile # Pipfile [requires] python_version = \"3.8\" Ejecutar pipenv lock para generar el Pipfile.lock adecuado. (mb) $ pipenv lock","title":"Actualizar Pipfile.lock"},{"location":"5_message_board_app/#crear-procfile","text":"Le dir\u00e1 a Heroku c\u00f3mo ejecutar el servidor remoto donde habita el c\u00f3digo. (mb) $ touch Procfile","title":"Crear Procfile"},{"location":"5_message_board_app/#instalar-gunicorn","text":"Por ahora Heroku usa gunicorn como servidor de producci\u00f3n y mira en el fichero mb_project.wsgi para m\u00e1s instrucciones. web: gunicorn mb_project.wsgi --log-file - Luego, se instala gunicorn , que se usar\u00e1 en producci\u00f3n mientras se siga usando el servidor interno de Django para desarrollo local. (mb) $ pipenv install gunicorn","title":"Instalar gunicorn"},{"location":"5_message_board_app/#actualizar-settingspy","text":"Actualizar ALLOWED_HOSTS en el archivo settings.py . FICHERO: mb_project/settings.py # mb_project/settings.py ALLOWED_HOSTS = ['*'] commit y push (mb) $ git status (mb) $ git add -A (mb) $ git commit -m 'New updates for Heroku deployment' (mb) $ git push -u origin master","title":"Actualizar settings.py"},{"location":"5_message_board_app/#despliegue-en-heroku","text":"Login (mb) $ heroku login Create .- Genera un nombre aleatorio para la aplicaci\u00f3n (mb) $ heroku create Creating app... done,agile-inlet-25811 https://agile-inlet-25811.herokuapp.com/ | https://git.heroku.com/agile-inlet-25811.git Establecer a git para usar el nombre de la nueva aplicaci\u00f3n cuando se suba el c\u00f3digo a Heroku. (mb) $ heroku git:remote -a agile-inlet-25811 Indicar a que ignore los archivos est\u00e1ticos (se tratar\u00e1 m\u00e1s adelante). (mb) $ heroku config:set DISABLE_COLLECTSTATIC=1 Subir el c\u00f3digo a Heroku y a\u00f1adir escalado gratuito para que se ejecute realmente en l\u00ednea, de lo contrario el c\u00f3digo s\u00f3lo se quedar\u00e1 alojado. (mb) $ git push heroku master (mb) $ heroku ps:scale web=1 Abrir el c\u00f3digo con heroku open y autom\u00e1ticamente mostrar\u00e1 un navegador con la URL de la aplicaci\u00f3n.","title":"Despliegue en Heroku"},{"location":"5_message_board_app/#conclusion","text":"Se ha construido, probado e implementado la primera aplicaci\u00f3n b\u00e1sica basada en una base de datos. Faltar\u00edan formularios para interactuar con el sitio (el panel de administraci\u00f3n no es lo adecuado). Se crear\u00e1 una aplicaci\u00f3n de blog con formularios para que los usuarios puedan crear, editar y borrar mensajes. Se le a\u00f1adir\u00e1 estilo a trav\u00e9s de CSS.","title":"Conclusi\u00f3n"},{"location":"6_blog_app/","text":"Blog app Se construir\u00e1 una aplicaci\u00f3n de Blog que permita a los usuarios crear, editar y eliminar posts. La p\u00e1gina de inicio listar\u00e1 todos los art\u00edculos del blog Habr\u00e1 una p\u00e1gina de detalles dedicada a cada art\u00edculo individual. Se introduce CSS para el estilo y se ver\u00e1 c\u00f3mo funciona Django con los archivos est\u00e1ticos. Configuraci\u00f3n inicial Nuevo proyecto Django: - crear un nuevo directorio para el c\u00f3digo en el Escritorio llamado blog - instalar Django en un nuevo entorno virtual - crear un nuevo proyecto de Django llamado blog_project - crear un nuevo blog de aplicaciones - realizar una migraci\u00f3n para configurar la base de datos - actualizar settings.py $ cd ~/Desktop $ mkdir blog $ cd blog $ pipenv install django $ pipenv shell (blog) $ django-admin startproject blog_project . (blog) $ python manage.py startapp blog (blog) $ python manage.py migrate (blog) $ python manage.py runserver FICHERO: blog_project/settings.py # blog_project/settings.py INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', \u00e7 'blog', # new ] Modelos de Bases de Datos Se asume que cada post tiene un t\u00edtulo, un autor y un cuerpo que se convertir\u00e1n en un modelo de base de datos: FICHERO: blog/models.py from django.db import models class Post(models.Model): title = models.CharField(max_length=200) author = models.ForeignKey( 'auth.User', on_delete=models.CASCADE, ) body = models.TextField() def __str__(self): return self.title Se importan los modelos de la clase y luego se crea una subclase del modelo llamada Post . Usando esta funcionalidad de subclase se tiene acceso autom\u00e1ticamente a todo lo que hay dentro de django.db.models.Models y se pueden a\u00f1adir campos y m\u00e9todos adicionales seg\u00fan se desee. El t\u00edtulo se limita a 200 caracteres y para el cuerpo se usa un campo de texto que se expandir\u00e1 autom\u00e1ticamente seg\u00fan sea necesario para adaptarse al texto del usuario. Hay muchos tipos de campos disponibles en Django; se puede ver la lista completa aqu\u00ed . Para el campo de autor se usa una clave for\u00e1nea ( ForeignKey ) que permite una relaci\u00f3n de uno a muchos : un autor puede tener muchas entradas de blog diferentes, pero no al rev\u00e9s. La referencia auth.User es para el modelo de usuario incorporado que Django proporciona para la autenticaci\u00f3n. Para todas las relaciones de uno a muchos, con ForeignKey , tambi\u00e9n debemos especificar una opci\u00f3n de on_delete . Ahora que se ha creado el nuevo modelo de base de datos, se necesita crear un nuevo registro de migraci\u00f3n para \u00e9l y migrar el cambio a la base de datos. Este proceso de dos pasos se puede completar con los siguientes comandos: (blog) $ python manage.py makemigrations blog (blog) $ python manage.py migrate blog Base de datos configurada. Admin Para acceder a los datos: Crear una cuenta de superusuario ```bash (blog) $ python manage.py createsuperuser Username (leave blank to use 'wsv'): wsv Email: Password: Password (again): Superuser created successfully. ``` ``` - Arrancar el servidor y abrir http://127.0.0.1:8000/admin/ - Logear con la nueva cuenta de superusuario - !Ups! \u00bfD\u00f3nde esta nuevo modelo Post? - Se olvid\u00f3 actualizar `blog/admin.py` FICHERO: `blog/admin.py` blog/admin.py from django.contrib import admin from .models import Post admin.site.register(Post) - Refrescar ahora y a\u00f1adir dos blog post para tener algunos datos de muestra con los que trabajar + A\u00f1adir un \"autor\" a cada entrada tambi\u00e9n, ya que por defecto todos los campos del modelo son obligatorios ## URLs \u200b```bash (blog) $ touch blog/urls.py FICHERO: blog/urls.py from django.urls import path from . import views urlpatterns = [ path('', views.BlogListView.as_view(), name='home'), ] FICHERO: blog_project/urls.py from django.contrib import admin from django.urls import path, include urlpatterns = [ path('admin/', admin.site.urls), path('', include('blog.urls')), ] Views FICHERO: blog/views.py from django.views.generic import ListView from . models import Post class BlogListView(ListView): model = Post template_name = 'home.html' Templates (blog) $ mkdir templates (blog) $ touch templates/base.html (blog) $ touch templates/home.html FICHERO: blog_project/settings.py TEMPLATES = [ { ... 'DIRS': [os.path.join(BASE_DIR, 'templates')], ... }, ] FICHERO: templates/base.html <html> <head> <title>Django blog</title> </head> <body> <header> <h1><a href=\"/\">Django blog</a></h1> </header> <div class=\"container\"> {% block content %} {% endblock content %} </div> </body> </html> El c\u00f3digo entre {% block content %} y {% endblock content %} puede llenarse con otras plantillas. FICHERO: templates/home.html {% extends 'base.html' %} {% block content %} {% for post in object_list %} <div class=\"post-entry\"> <h2><a href=\"\">{{ post.title }}</a></h2> <p>{{ post.body }}</p> </div> {% endfor %} {% endblock content %} Observar que object_list proviene de ListView y contiene todos los objetos de la vista. Iniciar de nuevo el servidor Django: python manage.py runserver Terrible, \u00bfno? Ficheros est\u00e1ticos Un poco de CSS, please En un proyecto Django listo para la producci\u00f3n, normalmente se almacenar\u00eda en una red de distribuci\u00f3n de contenidos (CDN, Content Delivery Network ) para un mejor rendimiento, pero para este caso, el almacenamiento de los archivos en local est\u00e1 bien. (blog) $ mkdir static Al igual que se hizo con la carpeta de plantillas, se necesita actualizar el archivo settings.py para decirle a Django d\u00f3nde buscar estos archivos est\u00e1ticos. A\u00f1adir en la parte inferior del archivo, debajo de la entrada para STATIC_URL . FICHERO: blog_project/settings.py STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')] Crear una carpeta css dentro de static y crear el fichero base.css (blog) $ mkdir static/css (blog) $ touch static/css/base.css FICHERO: satic/css/base.css header h1 a { color: red; } A\u00f1adir el fichero est\u00e1tico a la plantilla a\u00f1adiendo {% load staticfiles %} al pricipio de base.html Como las otras plantillas se heredan de base.html s\u00f3lo hay que a\u00f1adirlo una vez FICHERO: templates/base.html {% load static %} <html> <head> <title>Django blog</title> <link rel=\"stylesheet\" href=\"{% static 'css/base.css' %}\"> </head> ... Ahora se pueden a\u00f1adir archivos est\u00e1ticos y aparecer\u00e1n autom\u00e1ticamente en todas las plantillas. \u00bfQu\u00e9 tal si se a\u00f1ade una fuente personalizada y algo m\u00e1s de CSS? FICHERO: templates/base.html {% load static %} <html> <head> <title>Django blog</title> <link href=\"https://fonts.googleapis.com/css?family=Source+Sans+Pro:4000\" rel=\"\\stylesheet\"> <link rel=\"stylesheet\" href=\"{% static 'css/base.css' %}\"> </head> ... Actualizar el archivo css FICHERO: static/css/base.css body { font-family: 'Source Sans Pro', sans-serif; font-size: 18px; } header { border-bottom: 1px solid #999; margin-bottom: 2rem; display: flex; } header h1 a { color: red; text-decoration: none; } .nav-left { margin-right: auto; } .nav-right { display: flex; padding-top: 2rem; } .post-entry { margin-bottom: 2rem; } .post-entry h2 { margin: 0.5rem 0; } .post-entry h2 a, .post-entry h2 a:visited { color: blue; text-decoration: none; } .post-entry p { margin: 0; font-weight: 400; } .post-entry h2 a:hover { color: red; } Individual blog pages Ahora se puede a\u00f1adir funcionalidad a las p\u00e1ginas de blog individuales. Crear una nueva vista, url y plantilla. Se puede usar la vista gen\u00e9rica basada en clases DetailView para simplificar las cosas. FICHERO: blog/views.py from django.views.generic import ListView, DetailView from . models import Post class BlogListView(ListView): model = Post template_name = 'home.html' class BlogDetailView(DetailView): model = Post template_name = 'post_detail.html' Por defecto DetailView proporciona un objeto de contexto que podemos usar en la plantilla llamado objeto o el nombre en min\u00fasculas de nuestro modelo, post . Adem\u00e1s, DetailView espera que se le pase una clave primaria o un slug como identificador. M\u00e1s sobre esto en breve. (blog) $ touch templates/post_detail.html FICHERO: templates/post_detail.html {% extends 'base.html' %} {% block content %} <div class=\"post-entry\"> <h2>{{ post.title }}</h2> <p>{{ post.body }}</p> </div> {% endblock content %} En la parte superior se especifica que esta plantilla hereda de base.html. Luego se muestra el t\u00edtulo y cuerpo del objeto de contexto, que DetailView hace accesible como post . La denominaci\u00f3n de los objetos de contexto en vistas gen\u00e9ricas es extremadamente confusa cuando se ve Django por primera vez. Debido a que nuestro objeto de contexto de DetailView es o bien el nombre de modelo post o bien object , podr\u00edamos tambi\u00e9n actualizar nuestro modelo de la siguiente manera y funcionar\u00eda exactamente igual. FICHERO: templates/post_detail.html {% extends 'base.html' %} {% block content %} <div class=\"post-entry\"> <h2>{{ object.title }}</h2> <p>{{ object.body }}</p> </div> {% endblock content %} Si se encuentra confuso el uso de post o de objeto , tambi\u00e9n podemos establecer expl\u00edcitamente el nombre del objeto del contexto en la vista. As\u00ed que si quisi\u00e9ramos llamarlo anything_you_want y luego usarlo en la plantilla, el c\u00f3digo tendr\u00eda el siguiente aspecto y funcionar\u00eda igual. FICHERO: blog/views.py ... class BlogDetailView(DetailView): model = Post template_name = 'post_detail.html' context_object_name = 'anything_you_want' FICHERO: templates/post_detail.html {% extends 'base.html' %} {% block content %} <div class=\"post-entry\"> <h2>{{ anything_you_want.title }}</h2> <p>{{ anything_you_want.body }}</p> </div> {% endblock content %} La \"magia\" en la denominaci\u00f3n del objeto de contexto es un precio que se paga por la facilidad y la sencillez del uso de vistas gen\u00e9ricas. Son geniales si se sabe lo que se hace pero pueden ser dif\u00edciles de personalizar si se quiere un comportamiento diferente. A\u00f1adir una nueva URLConf para la vista FICHERO: blog/urls.py from django.urls import path from . import views urlpatterns = [ path('', views.BlogListView.as_view(), name='home'), path('post/<int:pk>/', views.BlogDetailView.as_view(), name='post_detail'), ] Todas las entradas del blog comenzar\u00e1n con post/ . Lo siguiente es la clave principal de la entrada que se representar\u00e1 como un entero <int:pk> . \u00bfCu\u00e1l es la clave primaria? Django a\u00f1ade autom\u00e1ticamente una clave primaria autoincrementada a los modelos de base de datos. As\u00ed que mientras que s\u00f3lo se declaran los campos title , author and body en el modelo de publicaci\u00f3n, bajo el cap\u00f3 Django tambi\u00e9n a\u00f1adi\u00f3 otro campo llamado id , que es la clave primaria. Se puede acceder a ella como id o pk . El pk para el primer post \"Hola, Mundo\" es 1. Para el segundo post, es 2. Y as\u00ed sucesivamente. Por lo tanto, cuando vayamos a la p\u00e1gina de entrada individual para nuestro primer post, podemos esperar que su patr\u00f3n de direcci\u00f3n sea post/1 . Nota: Entender c\u00f3mo funcionan claves primarias con DetailView es un lugar de confusi\u00f3n muy com\u00fan para los principiantes. Vale la pena releer los dos p\u00e1rrafos anteriores unas cuantas veces. Con la pr\u00e1ctica se convertir\u00e1 en algo natural. Si se inicia el servidor con python manage.py runserver y se va directamente a http://127.0.0.1:8000/post/1/ se ver\u00e1 una p\u00e1gina dedicada para la primera entrada en el blog. Tambi\u00e9n se puede ir a http://127.0.0.1:8000/post/2/ para ver la segunda entrada. Para facilitar el acceso, se deber\u00eda actualizar el enlace en la p\u00e1gina de inicio para poder acceder directamente a las entradas individuales del blog desde all\u00ed. Actualmente en home.html el enlace est\u00e1 vac\u00edo: <a href=\"\"> . Actualizarlo a <a href=\"{% url 'post_detail' post.pk %}\"> . FICHERO: templates/home.html {% extends 'base.html' %} {% block content %} {% for post in object_list %} <div class=\"post-entry\"> <h2><a href=\"{% url 'post_detail' post.pk %}\">{{ post.title }}</a></h2> <p>{{ post.body }}</p> </div> {% endfor %} {% endblock content %} Se empieza diciendo a la plantilla de Django que se quiere hacer referencia a una URLConf usando el c\u00f3digo {% url ... %} \u00bfQu\u00e9 URL?.- La que se llama post_detail , que es el nombre que se le di\u00f3 a BlogDetailView en la URLConf hace un momento. Si se mira a post_detail en URLConf , se observa que espera que se le pase un argumento pk que representa la clave primaria para la entrada del blog. Afortunadamente, Django ya ha creado e incluido este campo pk en el objeto post . Se pasa a la URLConf a\u00f1adi\u00e9ndolo en la plantilla como post.pk . Tests FICHERO: blog/tests.py from django.contrib.auth import get_user_model from django.test import Client, TestCase from django.urls import reverse from .models import Post class BlogTests(TestCase): def setUp(self): self.user = get_user_model().objects.create_user( username='testuser', email='test@email.com', password='secret' ) self.post = Post.objects.create( title='A good title', body='Nice body content', author=self.user, ) def test_string_representation(self): post = Post(title='A sample title') self.assertEqual(str(post), post.title) def test_post_content(self): self.assertEqual(f'{self.post.title}', 'A good title') self.assertEqual(f'{self.post.author}', 'testuser') self.assertEqual(f'{self.post.body}', 'Nice body content') def test_post_list_view(self): response = self.client.get(reverse('home')) self.assertEqual(response.status_code, 200) self.assertContains(response, 'Nice body content') self.assertTemplateUsed(response, 'home.html') def test_post_detail_view(self): response = self.client.get('/post/1/') no_response = self.client.get('/post/100000/') self.assertEqual(response.status_code, 200) self.assertEqual(no_response.status_code, 404) self.assertContains(response, 'A good title') self.assertTemplateUsed(response, 'post_detail.html') Hay muchas cosas nuevas en estas pruebas, as\u00ed que se recorrer\u00e1n lentamente. En la parte superior se importa get_user_model para referenciar al usuario activo. Se importa TestCase que se ha visto antes y tambi\u00e9n Client() que es nuevo y se usa como un navegador web falso para simular peticiones GET y POST en una URL . En otras palabras, siempre que se est\u00e9 probando vistas se usar\u00e1 Client() . En el m\u00e9todo de configuraci\u00f3n se a\u00f1ade una entrada de blog de muestra para probar y luego se confirma que tanto la representaci\u00f3n de la cadena como el contenido son correctos. Luego se usa test_post_list_view para confirmar que la p\u00e1gina de inicio devuelve un c\u00f3digo de estado HTTP 200 , contiene el texto del cuerpo y usa la plantilla home.html correcta. Finalmente test_post_detail_view comprueba que la p\u00e1gina de detalles funciona como se espera y que una p\u00e1gina incorrecta devuelve un 404 . Siempre es bueno probar que algo existe y que algo incorrecto no existe en las pruebas. (testy) $ python manage.py test Git Ahora tambi\u00e9n es un buen momento para el primer commit de git. (testy) $ git init (testy) $ git status (testy) $ git add -A (testy) $ git commit -m 'initial commit' Conclusi\u00f3n Se ha construido una aplicaci\u00f3n b\u00e1sica de blog desde cero Usando el administrador de Django se puede crear, editar o borrar el contenido. Se ha usado DetailView por primera vez para crear una vista individual detallada de cada entrada del blog.","title":"Blog app"},{"location":"6_blog_app/#blog-app","text":"Se construir\u00e1 una aplicaci\u00f3n de Blog que permita a los usuarios crear, editar y eliminar posts. La p\u00e1gina de inicio listar\u00e1 todos los art\u00edculos del blog Habr\u00e1 una p\u00e1gina de detalles dedicada a cada art\u00edculo individual. Se introduce CSS para el estilo y se ver\u00e1 c\u00f3mo funciona Django con los archivos est\u00e1ticos.","title":"Blog app"},{"location":"6_blog_app/#configuracion-inicial","text":"Nuevo proyecto Django: - crear un nuevo directorio para el c\u00f3digo en el Escritorio llamado blog - instalar Django en un nuevo entorno virtual - crear un nuevo proyecto de Django llamado blog_project - crear un nuevo blog de aplicaciones - realizar una migraci\u00f3n para configurar la base de datos - actualizar settings.py $ cd ~/Desktop $ mkdir blog $ cd blog $ pipenv install django $ pipenv shell (blog) $ django-admin startproject blog_project . (blog) $ python manage.py startapp blog (blog) $ python manage.py migrate (blog) $ python manage.py runserver FICHERO: blog_project/settings.py # blog_project/settings.py INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', \u00e7 'blog', # new ]","title":"Configuraci\u00f3n inicial"},{"location":"6_blog_app/#modelos-de-bases-de-datos","text":"Se asume que cada post tiene un t\u00edtulo, un autor y un cuerpo que se convertir\u00e1n en un modelo de base de datos: FICHERO: blog/models.py from django.db import models class Post(models.Model): title = models.CharField(max_length=200) author = models.ForeignKey( 'auth.User', on_delete=models.CASCADE, ) body = models.TextField() def __str__(self): return self.title Se importan los modelos de la clase y luego se crea una subclase del modelo llamada Post . Usando esta funcionalidad de subclase se tiene acceso autom\u00e1ticamente a todo lo que hay dentro de django.db.models.Models y se pueden a\u00f1adir campos y m\u00e9todos adicionales seg\u00fan se desee. El t\u00edtulo se limita a 200 caracteres y para el cuerpo se usa un campo de texto que se expandir\u00e1 autom\u00e1ticamente seg\u00fan sea necesario para adaptarse al texto del usuario. Hay muchos tipos de campos disponibles en Django; se puede ver la lista completa aqu\u00ed . Para el campo de autor se usa una clave for\u00e1nea ( ForeignKey ) que permite una relaci\u00f3n de uno a muchos : un autor puede tener muchas entradas de blog diferentes, pero no al rev\u00e9s. La referencia auth.User es para el modelo de usuario incorporado que Django proporciona para la autenticaci\u00f3n. Para todas las relaciones de uno a muchos, con ForeignKey , tambi\u00e9n debemos especificar una opci\u00f3n de on_delete . Ahora que se ha creado el nuevo modelo de base de datos, se necesita crear un nuevo registro de migraci\u00f3n para \u00e9l y migrar el cambio a la base de datos. Este proceso de dos pasos se puede completar con los siguientes comandos: (blog) $ python manage.py makemigrations blog (blog) $ python manage.py migrate blog Base de datos configurada.","title":"Modelos de Bases de Datos"},{"location":"6_blog_app/#admin","text":"","title":"Admin"},{"location":"6_blog_app/#para-acceder-a-los-datos","text":"Crear una cuenta de superusuario ```bash (blog) $ python manage.py createsuperuser Username (leave blank to use 'wsv'): wsv Email: Password: Password (again): Superuser created successfully. ``` ``` - Arrancar el servidor y abrir http://127.0.0.1:8000/admin/ - Logear con la nueva cuenta de superusuario - !Ups! \u00bfD\u00f3nde esta nuevo modelo Post? - Se olvid\u00f3 actualizar `blog/admin.py` FICHERO: `blog/admin.py`","title":"Para acceder a los datos:"},{"location":"6_blog_app/#blogadminpy","text":"from django.contrib import admin from .models import Post admin.site.register(Post) - Refrescar ahora y a\u00f1adir dos blog post para tener algunos datos de muestra con los que trabajar + A\u00f1adir un \"autor\" a cada entrada tambi\u00e9n, ya que por defecto todos los campos del modelo son obligatorios ## URLs \u200b```bash (blog) $ touch blog/urls.py FICHERO: blog/urls.py from django.urls import path from . import views urlpatterns = [ path('', views.BlogListView.as_view(), name='home'), ] FICHERO: blog_project/urls.py from django.contrib import admin from django.urls import path, include urlpatterns = [ path('admin/', admin.site.urls), path('', include('blog.urls')), ]","title":"blog/admin.py"},{"location":"6_blog_app/#views","text":"FICHERO: blog/views.py from django.views.generic import ListView from . models import Post class BlogListView(ListView): model = Post template_name = 'home.html'","title":"Views"},{"location":"6_blog_app/#templates","text":"(blog) $ mkdir templates (blog) $ touch templates/base.html (blog) $ touch templates/home.html FICHERO: blog_project/settings.py TEMPLATES = [ { ... 'DIRS': [os.path.join(BASE_DIR, 'templates')], ... }, ] FICHERO: templates/base.html <html> <head> <title>Django blog</title> </head> <body> <header> <h1><a href=\"/\">Django blog</a></h1> </header> <div class=\"container\"> {% block content %} {% endblock content %} </div> </body> </html> El c\u00f3digo entre {% block content %} y {% endblock content %} puede llenarse con otras plantillas. FICHERO: templates/home.html {% extends 'base.html' %} {% block content %} {% for post in object_list %} <div class=\"post-entry\"> <h2><a href=\"\">{{ post.title }}</a></h2> <p>{{ post.body }}</p> </div> {% endfor %} {% endblock content %} Observar que object_list proviene de ListView y contiene todos los objetos de la vista. Iniciar de nuevo el servidor Django: python manage.py runserver Terrible, \u00bfno?","title":"Templates"},{"location":"6_blog_app/#ficheros-estaticos","text":"Un poco de CSS, please En un proyecto Django listo para la producci\u00f3n, normalmente se almacenar\u00eda en una red de distribuci\u00f3n de contenidos (CDN, Content Delivery Network ) para un mejor rendimiento, pero para este caso, el almacenamiento de los archivos en local est\u00e1 bien. (blog) $ mkdir static Al igual que se hizo con la carpeta de plantillas, se necesita actualizar el archivo settings.py para decirle a Django d\u00f3nde buscar estos archivos est\u00e1ticos. A\u00f1adir en la parte inferior del archivo, debajo de la entrada para STATIC_URL . FICHERO: blog_project/settings.py STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')] Crear una carpeta css dentro de static y crear el fichero base.css (blog) $ mkdir static/css (blog) $ touch static/css/base.css FICHERO: satic/css/base.css header h1 a { color: red; } A\u00f1adir el fichero est\u00e1tico a la plantilla a\u00f1adiendo {% load staticfiles %} al pricipio de base.html Como las otras plantillas se heredan de base.html s\u00f3lo hay que a\u00f1adirlo una vez FICHERO: templates/base.html {% load static %} <html> <head> <title>Django blog</title> <link rel=\"stylesheet\" href=\"{% static 'css/base.css' %}\"> </head> ... Ahora se pueden a\u00f1adir archivos est\u00e1ticos y aparecer\u00e1n autom\u00e1ticamente en todas las plantillas. \u00bfQu\u00e9 tal si se a\u00f1ade una fuente personalizada y algo m\u00e1s de CSS? FICHERO: templates/base.html {% load static %} <html> <head> <title>Django blog</title> <link href=\"https://fonts.googleapis.com/css?family=Source+Sans+Pro:4000\" rel=\"\\stylesheet\"> <link rel=\"stylesheet\" href=\"{% static 'css/base.css' %}\"> </head> ... Actualizar el archivo css FICHERO: static/css/base.css body { font-family: 'Source Sans Pro', sans-serif; font-size: 18px; } header { border-bottom: 1px solid #999; margin-bottom: 2rem; display: flex; } header h1 a { color: red; text-decoration: none; } .nav-left { margin-right: auto; } .nav-right { display: flex; padding-top: 2rem; } .post-entry { margin-bottom: 2rem; } .post-entry h2 { margin: 0.5rem 0; } .post-entry h2 a, .post-entry h2 a:visited { color: blue; text-decoration: none; } .post-entry p { margin: 0; font-weight: 400; } .post-entry h2 a:hover { color: red; }","title":"Ficheros est\u00e1ticos"},{"location":"6_blog_app/#individual-blog-pages","text":"Ahora se puede a\u00f1adir funcionalidad a las p\u00e1ginas de blog individuales. Crear una nueva vista, url y plantilla. Se puede usar la vista gen\u00e9rica basada en clases DetailView para simplificar las cosas. FICHERO: blog/views.py from django.views.generic import ListView, DetailView from . models import Post class BlogListView(ListView): model = Post template_name = 'home.html' class BlogDetailView(DetailView): model = Post template_name = 'post_detail.html' Por defecto DetailView proporciona un objeto de contexto que podemos usar en la plantilla llamado objeto o el nombre en min\u00fasculas de nuestro modelo, post . Adem\u00e1s, DetailView espera que se le pase una clave primaria o un slug como identificador. M\u00e1s sobre esto en breve. (blog) $ touch templates/post_detail.html FICHERO: templates/post_detail.html {% extends 'base.html' %} {% block content %} <div class=\"post-entry\"> <h2>{{ post.title }}</h2> <p>{{ post.body }}</p> </div> {% endblock content %} En la parte superior se especifica que esta plantilla hereda de base.html. Luego se muestra el t\u00edtulo y cuerpo del objeto de contexto, que DetailView hace accesible como post . La denominaci\u00f3n de los objetos de contexto en vistas gen\u00e9ricas es extremadamente confusa cuando se ve Django por primera vez. Debido a que nuestro objeto de contexto de DetailView es o bien el nombre de modelo post o bien object , podr\u00edamos tambi\u00e9n actualizar nuestro modelo de la siguiente manera y funcionar\u00eda exactamente igual. FICHERO: templates/post_detail.html {% extends 'base.html' %} {% block content %} <div class=\"post-entry\"> <h2>{{ object.title }}</h2> <p>{{ object.body }}</p> </div> {% endblock content %} Si se encuentra confuso el uso de post o de objeto , tambi\u00e9n podemos establecer expl\u00edcitamente el nombre del objeto del contexto en la vista. As\u00ed que si quisi\u00e9ramos llamarlo anything_you_want y luego usarlo en la plantilla, el c\u00f3digo tendr\u00eda el siguiente aspecto y funcionar\u00eda igual. FICHERO: blog/views.py ... class BlogDetailView(DetailView): model = Post template_name = 'post_detail.html' context_object_name = 'anything_you_want' FICHERO: templates/post_detail.html {% extends 'base.html' %} {% block content %} <div class=\"post-entry\"> <h2>{{ anything_you_want.title }}</h2> <p>{{ anything_you_want.body }}</p> </div> {% endblock content %} La \"magia\" en la denominaci\u00f3n del objeto de contexto es un precio que se paga por la facilidad y la sencillez del uso de vistas gen\u00e9ricas. Son geniales si se sabe lo que se hace pero pueden ser dif\u00edciles de personalizar si se quiere un comportamiento diferente. A\u00f1adir una nueva URLConf para la vista FICHERO: blog/urls.py from django.urls import path from . import views urlpatterns = [ path('', views.BlogListView.as_view(), name='home'), path('post/<int:pk>/', views.BlogDetailView.as_view(), name='post_detail'), ] Todas las entradas del blog comenzar\u00e1n con post/ . Lo siguiente es la clave principal de la entrada que se representar\u00e1 como un entero <int:pk> . \u00bfCu\u00e1l es la clave primaria? Django a\u00f1ade autom\u00e1ticamente una clave primaria autoincrementada a los modelos de base de datos. As\u00ed que mientras que s\u00f3lo se declaran los campos title , author and body en el modelo de publicaci\u00f3n, bajo el cap\u00f3 Django tambi\u00e9n a\u00f1adi\u00f3 otro campo llamado id , que es la clave primaria. Se puede acceder a ella como id o pk . El pk para el primer post \"Hola, Mundo\" es 1. Para el segundo post, es 2. Y as\u00ed sucesivamente. Por lo tanto, cuando vayamos a la p\u00e1gina de entrada individual para nuestro primer post, podemos esperar que su patr\u00f3n de direcci\u00f3n sea post/1 . Nota: Entender c\u00f3mo funcionan claves primarias con DetailView es un lugar de confusi\u00f3n muy com\u00fan para los principiantes. Vale la pena releer los dos p\u00e1rrafos anteriores unas cuantas veces. Con la pr\u00e1ctica se convertir\u00e1 en algo natural. Si se inicia el servidor con python manage.py runserver y se va directamente a http://127.0.0.1:8000/post/1/ se ver\u00e1 una p\u00e1gina dedicada para la primera entrada en el blog. Tambi\u00e9n se puede ir a http://127.0.0.1:8000/post/2/ para ver la segunda entrada. Para facilitar el acceso, se deber\u00eda actualizar el enlace en la p\u00e1gina de inicio para poder acceder directamente a las entradas individuales del blog desde all\u00ed. Actualmente en home.html el enlace est\u00e1 vac\u00edo: <a href=\"\"> . Actualizarlo a <a href=\"{% url 'post_detail' post.pk %}\"> . FICHERO: templates/home.html {% extends 'base.html' %} {% block content %} {% for post in object_list %} <div class=\"post-entry\"> <h2><a href=\"{% url 'post_detail' post.pk %}\">{{ post.title }}</a></h2> <p>{{ post.body }}</p> </div> {% endfor %} {% endblock content %} Se empieza diciendo a la plantilla de Django que se quiere hacer referencia a una URLConf usando el c\u00f3digo {% url ... %} \u00bfQu\u00e9 URL?.- La que se llama post_detail , que es el nombre que se le di\u00f3 a BlogDetailView en la URLConf hace un momento. Si se mira a post_detail en URLConf , se observa que espera que se le pase un argumento pk que representa la clave primaria para la entrada del blog. Afortunadamente, Django ya ha creado e incluido este campo pk en el objeto post . Se pasa a la URLConf a\u00f1adi\u00e9ndolo en la plantilla como post.pk .","title":"Individual blog pages"},{"location":"6_blog_app/#tests","text":"FICHERO: blog/tests.py from django.contrib.auth import get_user_model from django.test import Client, TestCase from django.urls import reverse from .models import Post class BlogTests(TestCase): def setUp(self): self.user = get_user_model().objects.create_user( username='testuser', email='test@email.com', password='secret' ) self.post = Post.objects.create( title='A good title', body='Nice body content', author=self.user, ) def test_string_representation(self): post = Post(title='A sample title') self.assertEqual(str(post), post.title) def test_post_content(self): self.assertEqual(f'{self.post.title}', 'A good title') self.assertEqual(f'{self.post.author}', 'testuser') self.assertEqual(f'{self.post.body}', 'Nice body content') def test_post_list_view(self): response = self.client.get(reverse('home')) self.assertEqual(response.status_code, 200) self.assertContains(response, 'Nice body content') self.assertTemplateUsed(response, 'home.html') def test_post_detail_view(self): response = self.client.get('/post/1/') no_response = self.client.get('/post/100000/') self.assertEqual(response.status_code, 200) self.assertEqual(no_response.status_code, 404) self.assertContains(response, 'A good title') self.assertTemplateUsed(response, 'post_detail.html') Hay muchas cosas nuevas en estas pruebas, as\u00ed que se recorrer\u00e1n lentamente. En la parte superior se importa get_user_model para referenciar al usuario activo. Se importa TestCase que se ha visto antes y tambi\u00e9n Client() que es nuevo y se usa como un navegador web falso para simular peticiones GET y POST en una URL . En otras palabras, siempre que se est\u00e9 probando vistas se usar\u00e1 Client() . En el m\u00e9todo de configuraci\u00f3n se a\u00f1ade una entrada de blog de muestra para probar y luego se confirma que tanto la representaci\u00f3n de la cadena como el contenido son correctos. Luego se usa test_post_list_view para confirmar que la p\u00e1gina de inicio devuelve un c\u00f3digo de estado HTTP 200 , contiene el texto del cuerpo y usa la plantilla home.html correcta. Finalmente test_post_detail_view comprueba que la p\u00e1gina de detalles funciona como se espera y que una p\u00e1gina incorrecta devuelve un 404 . Siempre es bueno probar que algo existe y que algo incorrecto no existe en las pruebas. (testy) $ python manage.py test","title":"Tests"},{"location":"6_blog_app/#git","text":"Ahora tambi\u00e9n es un buen momento para el primer commit de git. (testy) $ git init (testy) $ git status (testy) $ git add -A (testy) $ git commit -m 'initial commit'","title":"Git"},{"location":"6_blog_app/#conclusion","text":"Se ha construido una aplicaci\u00f3n b\u00e1sica de blog desde cero Usando el administrador de Django se puede crear, editar o borrar el contenido. Se ha usado DetailView por primera vez para crear una vista individual detallada de cada entrada del blog.","title":"Conclusi\u00f3n"},{"location":"7_Formularios/","text":"7. Formularios In this chapter we\u2019ll continue working on our blog application from Chapter 5 by adding forms so a user can create, edit, or delete any of their blog entries. 7.1 Formularios Los formularios son muy comunes y dif\u00edciles de implementar correctamente. Cada vez que se acepta la entrada de un usuario hay preocupaciones de: Seguridad (Ataques XSS) Se requiere un manejo adecuado de los errores Hay consideraciones de UI sobre c\u00f3mo alertar al usuario de problemas con el formulario. Sin mencionar la necesidad de redireccionarlo en caso de \u00e9xito. Afortunadamente, los formularios incorporados de Django abstraen gran parte de la dificultad y proporcionan un rico conjunto de herramientas para manejar los casos de uso com\u00fan que trabajan con los formularios. Actualizar la plantilla base para mostrar un enlace a una p\u00e1gina donde introducir nuevas entradas en el blog. Tomar\u00e1 la forma <a href=\"{% url 'post_new' %}\"><a/> donde post_new es el nombre de la URL. FICHERO: templates/base.html {% load staticfiles %} <html> <head> <title>Django blog</title> <link href=\"https://fonts.googleapis.com/css?family=Source+Sans+Pro:400\" rel=\"stylesheet\"> <link rel=\"stylesheet\" href=\"{% static 'css/base.css' %}\"> </head> <body> <div class=\"container\"> <header> <div class=\"nav-left\"> <h1><a href=\"/\">Django blog</a></h1> </div> <div class=\"nav-right\"> <a href=\"{% url 'post_new' %}\">+ New Blog Post</a> </div> </header> {% block content %} {% endblock content %} </div> </body> </html> FICHERO: blog/urls.py from django.urls import path from . import views urlpatterns = [ path('', views.BlogListView.as_view(), name='home'), path('post/<int:pk>/', views.BlogDetailView.as_view(), name='post_detail'), path('post/new/', views.BlogCreateView.as_view(), name='post_new'), ] La url empezar\u00e1 con post/new/ , la vista se llama BlogCreateView , y la url se llamar\u00e1 post_new . Crear la vista importando una nueva clase gen\u00e9rica llamada CreateView y luego heredarla para crear una nueva vista llamada BlogCreateView . FICHERO: blog/views.py from django.views.generic import ListView, DetailView from django.views.generic.edit import CreateView from . models import Post class BlogListView(ListView): model = Post template_name = 'home.html' class BlogDetailView(DetailView): model = Post template_name = 'post_detail.html' class BlogCreateView(CreateView): model = Post template_name = 'post_new.html' fields = '__all__' Dentro de BlogCreateView se especifica el modelo de base de datos Post , el nombre de la plantilla post_new.html , y todos los campos con '__all__' ya que s\u00f3lo hay dos: title y author . El \u00faltimo paso es crear la plantilla, que llamaremos post_new.html . (blog) $ touch templates/post_new.html FICHERO: templates/post_new.html {% extends 'base.html' %} {% block content %} <h1>New post</h1> <form action=\"\" method=\"post\">{% csrf_token %} {{ form.as_p }} <input type=\"submit\" value=\"Save\" /> </form> {% endblock %} En la l\u00ednea superior se hereda la plantilla base. Se usan etiquetas HTML <form> con el m\u00e9todo POST ya que se est\u00e1 enviando datos. Si se reciben datos de un formulario, por ejemplo en un cuadro de b\u00fasqueda, se utilizar\u00eda GET. Se a\u00f1ade un {% csrf_token %} que proporciona Django para proteger al formulario de ataques de cross-site scripting. Se debe usar en todos los formularios de Django. Luego para obtener los datos del formulario se usa {{ form.as_p }} que lo renderiza dentro etiquetas de p\u00e1rrafo <p> . Por \u00faltimo, se especifica un input type=\"submit\" con el valor \"Save\". Iniciar el servidor con python manage.py runserver e ir a la p\u00e1gina web en http://127.0.0.1:8000/.132 P\u00e1gina de inicio con el bot\u00f3n Nuevo Haga clic en nuestro enlace para \"+ Nueva entrada de blog\" que le redirigir\u00e1 a: http://127.0.0.1:8000/post/new/.133 Blog new page Go ahead and try to create a new blog post and submit it.134 Chapter 6: Forms Blog new page Oops! What happened?135 Chapter 6: Forms Blog new page Django\u2019s error message is quite helpful. It\u2019s complaining that we did not specify where to send the user after successfully submitting the form. Let\u2019s send a user to the detail page after success; that way they can see their completed post. We can follow Django\u2019s suggestion and add a get_absolute_url to our model. This is a best practice that you should always do. It sets a canonical URL for an object so even if the structure of your URLs changes in the future, the reference to the specific object is the same. In short, you should add a get_absolute_url() and str () method to each model you write. Open the models.py file. Add an import on the second line for reverse and a new get_- absolute_url method. Command Line FICHERO: blog/models.py from django.db import models from django.urls import reverse class Post(models.Model): title = models.CharField(max_length= ) author = models.ForeignKey( 'auth.User', on_delete=models.CASCADE, ) body = models.TextField() def __str__(self): return self.title def get_absolute_url(self): return reverse('post_detail', args=[str(self.id)]) Reverse is a very handy utility function Django provides us to reference an object by its URL template name, in this case post_detail . If you recall our URL pattern it is the following:137 Code path('post/ /', views.BlogDetailView.as_view(), name='post_detail'), That means in order for this route to work we must also pass in an argument with the pk or primary key of the object. Confusingly pk and id are interchangeable in Django though the Django docs recommend using self.id with get_absolute_url . So we\u2019re telling Django that the ultimate location of a Post entry is its post_detail view which is posts/ / so the route for the first entry we\u2019ve made will be at posts/ . Try to create a new blog post again at http://127.0.0.1:8000/post/new/ and you\u2019ll find upon success you are redirected to the detailed view page where the post appears. Blog new page with input You\u2019ll also notice that our earlier blog post is also there. It was successfully sent to the database, but Django didn\u2019t know how to redirect us after that. Blog homepage with four posts While we could go into the Django admin to delete unwanted posts, it\u2019s better if we add forms so a user can update and delete existing posts directly from the site. Update Form The process for creating an update form so users can edit blog posts should feel familiar. We\u2019ll again use a built-in Django class-based generic view, UpdateView, and create the requisite template, url, and view. To start, let\u2019s add a new link to post_detail.html so that the option to edit a blog post appears on an individual blog page. FICHERO: templates/post_detail.html {% extends 'base.html' %} {% block content %} <div class=\"post-entry\"> <h2>{{ object.title }}</h2> <p>{{ object.body }}</p> </div> <a href=\"{% url 'post_edit' post.pk %}\">+ Edit Blog Post</a> {% endblock content %} We\u2019ve added a link using ... and the Django template engine\u2019s {% url ... %} tag. Within it we\u2019ve specified the target name of our url, which will be called post_edit and also passed the parameter needed, which is the primary key of the post post.pk . Next we create the template for our edit page called post_edit.html . Command Line (blog) $ touch templates/post_edit.html And add the following code: FICHERO: templates/post_edit.html {% extends 'base.html' %} {% block content %} <h1>Edit post</h1> <form action=\"\" method=\"post\">{% csrf_token %} {{ form.as_p }} <input type=\"submit\" value=\"Update\" /> </form> {% endblock %} We again use HTML tags, Django\u2019s csrf_token for security, form.as_p to display our form fields with paragraph tags, and finally give it the value \u201cUpdate\u201d on the submit button. Now to our view. We need to import UpdateView on the second-from-the-top line and then subclass it in our new view BlogUpdateView . FICHERO: blog/views.py from django.views.generic import ListView, DetailView from django.views.generic.edit import CreateView, UpdateView from . models import Post class BlogListView(ListView): model = Post template_name = 'home.html' class BlogDetailView(DetailView): model = Post template_name = 'post_detail.html' class BlogCreateView(CreateView): model = Post template_name = 'post_new.html' fields = '__all__' class BlogUpdateView(UpdateView): model = Post fields = ['title', 'body'] template_name = 'post_edit.html' Notice that in BlogUpdateView we are explicitly listing the fields we want to use ['title', 'body'] rather than using ' all ' . This is because we assume that the author of the post is not changing; we only want the title and text to be editable. The final step is to update our urls.py file as follows:142 Chapter 6: Forms Code blog/urls.py from django.urls import path from . import views urlpatterns = [ path('', views.BlogListView.as_view(), name='home'), path('post/ /', views.BlogDetailView.as_view(), name='post_detail'), path('post/new/', views.BlogCreateView.as_view(), name='post_new'), path('post/ /edit/', views.BlogUpdateView.as_view(), name='post_edit'), ] At the top we add our view BlogUpdateView to the list of imported views, then created a new url pattern for /post/pk/edit and given it the name post_edit . Now if you click on a blog entry you\u2019ll see our new Edit button. Blog page with edit button143 Chapter 6: Forms If you click on \u201c+ Edit Blog Post\u201d you\u2019ll be redirected to http://127.0.0.1:8000/post/1/edit/ if it\u2019s your first blog post. Blog edit page Note that the form is pre-filled with our database\u2019s existing data for the post. Let\u2019s make a change...144 Chapter 6: Forms Blog edit page And after clicking the \u201cUpdate\u201d button we are redirected to the detail view of the post where you can see the change. This is because of our get_absolute_url setting. Navigate to the homepage and you can see the change next to all the other entries.145 Chapter 6: Forms Blog homepage with edited post Delete View The process for creating a form to delete blog posts is very similar to that for updating a post. We\u2019ll use yet another generic class-based view, DeleteView, to help and need to create a view, url, and template for the functionality. Let\u2019s start by adding a link to delete blog posts on our individual blog page, post_- detail.html .Chapter 6: Forms 146 Code {% extends 'base.html' %} {% block content %} {{ object.title }} {{ object.body }} + Edit Blog Post + Delete Blog Post {% endblock content %} Then create a new file for our delete page template. First quit the local server Control- c and then type the following command: Command Line (blog) $ touch templates/post_delete.html And fill it with this code:Chapter 6: Forms 147 Code {% extends 'base.html' %} {% block content %} Delete post {% csrf_token %} Are you sure you want to delete \"{{ post.title }}\"? {% endblock %} Note we are using post.title here to display the title of our blog post. We could also just use object.title as it too is provided by DetailView . Now update our views.py file, by importing DeleteView and reverse_lazy at the top, then create a new view that subclasses DeleteView . Code blog/views.py from django.views.generic import ListView, DetailView from django.views.generic.edit import CreateView, UpdateView, DeleteView from django.urls import reverse_lazy from . models import Post class BlogListView(ListView): model = PostChapter 6: Forms 148 template_name = 'home.html' class BlogDetailView(DetailView): model = Post template_name = 'post_detail.html' class BlogCreateView(CreateView): model = Post template_name = 'post_new.html' fields = ' all ' class BlogUpdateView(UpdateView): model = Post fields = ['title', 'body'] template_name = 'post_edit.html' class BlogDeleteView(DeleteView): model = Post template_name = 'post_delete.html' success_url = reverse_lazy('home') We use reverse_lazy as opposed to just reverse so that it won\u2019t execute the URL redirect until our view has finished deleting the blog post. Finally add a url by importing our view BlogDeleteView and adding a new pattern:Chapter 6: Forms 149 Code blog/urls.py from django.urls import path from . import views urlpatterns = [ path('', views.BlogListView.as_view(), name='home'), path('post/ /', views.BlogDetailView.as_view(), name='post_detail'), path('post/new/', views.BlogCreateView.as_view(), name='post_new'), path('post/ /edit/', views.BlogUpdateView.as_view(), name='post_edit'), path('post/ /delete/', views.BlogDeleteView.as_view(), name='post_delete'), ] If you start the server again python manage.py runserver and refresh the individual post page you\u2019ll see our \u201cDelete Blog Post\u201d link.150 Chapter 6: Forms Blog delete post Clicking on the link takes us to the delete page for the blog post, which displays the name of the blog post. Blog delete post page If you click on the \u201cConfirm\u201d button, it redirects you to the homepage where the blog post has been deleted!151 Chapter 6: Forms Homepage with post deleted So it works! Tests Time for tests to make sure everything works now\u2013and in the future\u2013as expected. We\u2019ve added a get_absolute_url method to our model and new views for create, update, and edit posts. That means we need four new tests: \u2022 def test_get_absolute_url \u2022 def test_post_create_view \u2022 def test_post_update_view \u2022 def test_post_delete_view Update your existing tests.py file as follows.Chapter 6: Forms Code blog/tests.py from django.contrib.auth import get_user_model from django.test import Client, TestCase from django.urls import reverse from .models import Post class BlogTests(TestCase): def setUp(self): self.user = get_user_model().objects.create_user( username='testuser', email='test@email.com', password='secret' ) self.post = Post.objects.create( title='A good title', body='Nice body content', author=self.user, ) def test_string_representation(self): post = Post(title='A sample title') self.assertEqual(str(post), post.title) 152153 Chapter 6: Forms def test_get_absolute_url(self): self.assertEquals(self.post.get_absolute_url(), '/post/ /') def test_post_content(self): self.assertEqual(f'{self.post.title}', 'A good title') self.assertEqual(f'{self.post.author}', 'testuser') self.assertEqual(f'{self.post.body}', 'Nice body content') def test_post_list_view(self): response = self.client.get(reverse('home')) self.assertEqual(response.status_code, ) self.assertContains(response, 'Nice body content') self.assertTemplateUsed(response, 'home.html') def test_post_detail_view(self): response = self.client.get('/post/ /') no_response = self.client.get('/post/ self.assertEqual(response.status_code, /') ) self.assertEqual(no_response.status_code, ) self.assertContains(response, 'A good title') self.assertTemplateUsed(response, 'post_detail.html') def test_post_create_view(self): response = self.client.post(reverse('post_new'), { 'title': 'New title', 'body': 'New text', 'author': self.user, })154 Chapter 6: Forms self.assertEqual(response.status_code, ) self.assertContains(response, 'New title') self.assertContains(response, 'New text') def test_post_update_view(self): response = self.client.post(reverse('post_edit', args=' '), { 'title': 'Updated title', 'body': 'Updated text', }) self.assertEqual(response.status_code, ) def test_post_delete_view(self): response = self.client.get( reverse('post_delete', args=' ')) self.assertEqual(response.status_code, ) We expect the url of our test to be at post/ / since there\u2019s only one post and the is its primary key Django adds automatically for us. To test create view we make a new response and then ensure that the response goes through (status code 200) and contains our new title and body text. For update view we access the first post\u2013which has a pk of which is passed in as the only argument\u2013and we confirm that it results in a 302 redirect. Finally we test our delete view by confirming that if we delete a post the status code is 200 for success. There\u2019s always more tests that can be added but this at least has coverage on all our new functionality. Conclusi\u00f3n In a small amount of code we\u2019ve built a blog application that allows for creating, reading, updating, and deleting blog posts. This core functionality is known by the acronym CRUD: Create-Read-Update-Delete. While there are multiple ways to achieve this same functionality\u2013we could have used function-based views or written our own class-based views\u2013we\u2019ve demonstrated how little code it takes in Django to make this happen. In the next chapter we\u2019ll add user accounts and login, logout, and signup functionality.","title":"7. Formularios"},{"location":"7_Formularios/#7-formularios","text":"In this chapter we\u2019ll continue working on our blog application from Chapter 5 by adding forms so a user can create, edit, or delete any of their blog entries.","title":"7. Formularios"},{"location":"7_Formularios/#71-formularios","text":"Los formularios son muy comunes y dif\u00edciles de implementar correctamente. Cada vez que se acepta la entrada de un usuario hay preocupaciones de: Seguridad (Ataques XSS) Se requiere un manejo adecuado de los errores Hay consideraciones de UI sobre c\u00f3mo alertar al usuario de problemas con el formulario. Sin mencionar la necesidad de redireccionarlo en caso de \u00e9xito. Afortunadamente, los formularios incorporados de Django abstraen gran parte de la dificultad y proporcionan un rico conjunto de herramientas para manejar los casos de uso com\u00fan que trabajan con los formularios. Actualizar la plantilla base para mostrar un enlace a una p\u00e1gina donde introducir nuevas entradas en el blog. Tomar\u00e1 la forma <a href=\"{% url 'post_new' %}\"><a/> donde post_new es el nombre de la URL. FICHERO: templates/base.html {% load staticfiles %} <html> <head> <title>Django blog</title> <link href=\"https://fonts.googleapis.com/css?family=Source+Sans+Pro:400\" rel=\"stylesheet\"> <link rel=\"stylesheet\" href=\"{% static 'css/base.css' %}\"> </head> <body> <div class=\"container\"> <header> <div class=\"nav-left\"> <h1><a href=\"/\">Django blog</a></h1> </div> <div class=\"nav-right\"> <a href=\"{% url 'post_new' %}\">+ New Blog Post</a> </div> </header> {% block content %} {% endblock content %} </div> </body> </html> FICHERO: blog/urls.py from django.urls import path from . import views urlpatterns = [ path('', views.BlogListView.as_view(), name='home'), path('post/<int:pk>/', views.BlogDetailView.as_view(), name='post_detail'), path('post/new/', views.BlogCreateView.as_view(), name='post_new'), ] La url empezar\u00e1 con post/new/ , la vista se llama BlogCreateView , y la url se llamar\u00e1 post_new . Crear la vista importando una nueva clase gen\u00e9rica llamada CreateView y luego heredarla para crear una nueva vista llamada BlogCreateView . FICHERO: blog/views.py from django.views.generic import ListView, DetailView from django.views.generic.edit import CreateView from . models import Post class BlogListView(ListView): model = Post template_name = 'home.html' class BlogDetailView(DetailView): model = Post template_name = 'post_detail.html' class BlogCreateView(CreateView): model = Post template_name = 'post_new.html' fields = '__all__' Dentro de BlogCreateView se especifica el modelo de base de datos Post , el nombre de la plantilla post_new.html , y todos los campos con '__all__' ya que s\u00f3lo hay dos: title y author . El \u00faltimo paso es crear la plantilla, que llamaremos post_new.html . (blog) $ touch templates/post_new.html FICHERO: templates/post_new.html {% extends 'base.html' %} {% block content %} <h1>New post</h1> <form action=\"\" method=\"post\">{% csrf_token %} {{ form.as_p }} <input type=\"submit\" value=\"Save\" /> </form> {% endblock %} En la l\u00ednea superior se hereda la plantilla base. Se usan etiquetas HTML <form> con el m\u00e9todo POST ya que se est\u00e1 enviando datos. Si se reciben datos de un formulario, por ejemplo en un cuadro de b\u00fasqueda, se utilizar\u00eda GET. Se a\u00f1ade un {% csrf_token %} que proporciona Django para proteger al formulario de ataques de cross-site scripting. Se debe usar en todos los formularios de Django. Luego para obtener los datos del formulario se usa {{ form.as_p }} que lo renderiza dentro etiquetas de p\u00e1rrafo <p> . Por \u00faltimo, se especifica un input type=\"submit\" con el valor \"Save\". Iniciar el servidor con python manage.py runserver e ir a la p\u00e1gina web en http://127.0.0.1:8000/.132 P\u00e1gina de inicio con el bot\u00f3n Nuevo Haga clic en nuestro enlace para \"+ Nueva entrada de blog\" que le redirigir\u00e1 a: http://127.0.0.1:8000/post/new/.133 Blog new page Go ahead and try to create a new blog post and submit it.134 Chapter 6: Forms Blog new page Oops! What happened?135 Chapter 6: Forms Blog new page Django\u2019s error message is quite helpful. It\u2019s complaining that we did not specify where to send the user after successfully submitting the form. Let\u2019s send a user to the detail page after success; that way they can see their completed post. We can follow Django\u2019s suggestion and add a get_absolute_url to our model. This is a best practice that you should always do. It sets a canonical URL for an object so even if the structure of your URLs changes in the future, the reference to the specific object is the same. In short, you should add a get_absolute_url() and str () method to each model you write. Open the models.py file. Add an import on the second line for reverse and a new get_- absolute_url method. Command Line FICHERO: blog/models.py from django.db import models from django.urls import reverse class Post(models.Model): title = models.CharField(max_length= ) author = models.ForeignKey( 'auth.User', on_delete=models.CASCADE, ) body = models.TextField() def __str__(self): return self.title def get_absolute_url(self): return reverse('post_detail', args=[str(self.id)]) Reverse is a very handy utility function Django provides us to reference an object by its URL template name, in this case post_detail . If you recall our URL pattern it is the following:137 Code path('post/ /', views.BlogDetailView.as_view(), name='post_detail'), That means in order for this route to work we must also pass in an argument with the pk or primary key of the object. Confusingly pk and id are interchangeable in Django though the Django docs recommend using self.id with get_absolute_url . So we\u2019re telling Django that the ultimate location of a Post entry is its post_detail view which is posts/ / so the route for the first entry we\u2019ve made will be at posts/ . Try to create a new blog post again at http://127.0.0.1:8000/post/new/ and you\u2019ll find upon success you are redirected to the detailed view page where the post appears. Blog new page with input You\u2019ll also notice that our earlier blog post is also there. It was successfully sent to the database, but Django didn\u2019t know how to redirect us after that. Blog homepage with four posts While we could go into the Django admin to delete unwanted posts, it\u2019s better if we add forms so a user can update and delete existing posts directly from the site.","title":"7.1 Formularios"},{"location":"7_Formularios/#update-form","text":"The process for creating an update form so users can edit blog posts should feel familiar. We\u2019ll again use a built-in Django class-based generic view, UpdateView, and create the requisite template, url, and view. To start, let\u2019s add a new link to post_detail.html so that the option to edit a blog post appears on an individual blog page. FICHERO: templates/post_detail.html {% extends 'base.html' %} {% block content %} <div class=\"post-entry\"> <h2>{{ object.title }}</h2> <p>{{ object.body }}</p> </div> <a href=\"{% url 'post_edit' post.pk %}\">+ Edit Blog Post</a> {% endblock content %} We\u2019ve added a link using ... and the Django template engine\u2019s {% url ... %} tag. Within it we\u2019ve specified the target name of our url, which will be called post_edit and also passed the parameter needed, which is the primary key of the post post.pk . Next we create the template for our edit page called post_edit.html . Command Line (blog) $ touch templates/post_edit.html And add the following code: FICHERO: templates/post_edit.html {% extends 'base.html' %} {% block content %} <h1>Edit post</h1> <form action=\"\" method=\"post\">{% csrf_token %} {{ form.as_p }} <input type=\"submit\" value=\"Update\" /> </form> {% endblock %} We again use HTML tags, Django\u2019s csrf_token for security, form.as_p to display our form fields with paragraph tags, and finally give it the value \u201cUpdate\u201d on the submit button. Now to our view. We need to import UpdateView on the second-from-the-top line and then subclass it in our new view BlogUpdateView . FICHERO: blog/views.py from django.views.generic import ListView, DetailView from django.views.generic.edit import CreateView, UpdateView from . models import Post class BlogListView(ListView): model = Post template_name = 'home.html' class BlogDetailView(DetailView): model = Post template_name = 'post_detail.html' class BlogCreateView(CreateView): model = Post template_name = 'post_new.html' fields = '__all__' class BlogUpdateView(UpdateView): model = Post fields = ['title', 'body'] template_name = 'post_edit.html' Notice that in BlogUpdateView we are explicitly listing the fields we want to use ['title', 'body'] rather than using ' all ' . This is because we assume that the author of the post is not changing; we only want the title and text to be editable. The final step is to update our urls.py file as follows:142 Chapter 6: Forms Code","title":"Update Form"},{"location":"7_Formularios/#blogurlspy","text":"from django.urls import path from . import views urlpatterns = [ path('', views.BlogListView.as_view(), name='home'), path('post/ /', views.BlogDetailView.as_view(), name='post_detail'), path('post/new/', views.BlogCreateView.as_view(), name='post_new'), path('post/ /edit/', views.BlogUpdateView.as_view(), name='post_edit'), ] At the top we add our view BlogUpdateView to the list of imported views, then created a new url pattern for /post/pk/edit and given it the name post_edit . Now if you click on a blog entry you\u2019ll see our new Edit button. Blog page with edit button143 Chapter 6: Forms If you click on \u201c+ Edit Blog Post\u201d you\u2019ll be redirected to http://127.0.0.1:8000/post/1/edit/ if it\u2019s your first blog post. Blog edit page Note that the form is pre-filled with our database\u2019s existing data for the post. Let\u2019s make a change...144 Chapter 6: Forms Blog edit page And after clicking the \u201cUpdate\u201d button we are redirected to the detail view of the post where you can see the change. This is because of our get_absolute_url setting. Navigate to the homepage and you can see the change next to all the other entries.145 Chapter 6: Forms Blog homepage with edited post Delete View The process for creating a form to delete blog posts is very similar to that for updating a post. We\u2019ll use yet another generic class-based view, DeleteView, to help and need to create a view, url, and template for the functionality. Let\u2019s start by adding a link to delete blog posts on our individual blog page, post_- detail.html .Chapter 6: Forms 146 Code {% extends 'base.html' %} {% block content %}","title":"blog/urls.py"},{"location":"7_Formularios/#blogviewspy","text":"from django.views.generic import ListView, DetailView from django.views.generic.edit import CreateView, UpdateView, DeleteView from django.urls import reverse_lazy from . models import Post class BlogListView(ListView): model = PostChapter 6: Forms 148 template_name = 'home.html' class BlogDetailView(DetailView): model = Post template_name = 'post_detail.html' class BlogCreateView(CreateView): model = Post template_name = 'post_new.html' fields = ' all ' class BlogUpdateView(UpdateView): model = Post fields = ['title', 'body'] template_name = 'post_edit.html' class BlogDeleteView(DeleteView): model = Post template_name = 'post_delete.html' success_url = reverse_lazy('home') We use reverse_lazy as opposed to just reverse so that it won\u2019t execute the URL redirect until our view has finished deleting the blog post. Finally add a url by importing our view BlogDeleteView and adding a new pattern:Chapter 6: Forms 149 Code","title":"blog/views.py"},{"location":"7_Formularios/#blogurlspy_1","text":"from django.urls import path from . import views urlpatterns = [ path('', views.BlogListView.as_view(), name='home'), path('post/ /', views.BlogDetailView.as_view(), name='post_detail'), path('post/new/', views.BlogCreateView.as_view(), name='post_new'), path('post/ /edit/', views.BlogUpdateView.as_view(), name='post_edit'), path('post/ /delete/', views.BlogDeleteView.as_view(), name='post_delete'), ] If you start the server again python manage.py runserver and refresh the individual post page you\u2019ll see our \u201cDelete Blog Post\u201d link.150 Chapter 6: Forms Blog delete post Clicking on the link takes us to the delete page for the blog post, which displays the name of the blog post. Blog delete post page If you click on the \u201cConfirm\u201d button, it redirects you to the homepage where the blog post has been deleted!151 Chapter 6: Forms Homepage with post deleted So it works! Tests Time for tests to make sure everything works now\u2013and in the future\u2013as expected. We\u2019ve added a get_absolute_url method to our model and new views for create, update, and edit posts. That means we need four new tests: \u2022 def test_get_absolute_url \u2022 def test_post_create_view \u2022 def test_post_update_view \u2022 def test_post_delete_view Update your existing tests.py file as follows.Chapter 6: Forms Code","title":"blog/urls.py"},{"location":"7_Formularios/#blogtestspy","text":"from django.contrib.auth import get_user_model from django.test import Client, TestCase from django.urls import reverse from .models import Post class BlogTests(TestCase): def setUp(self): self.user = get_user_model().objects.create_user( username='testuser', email='test@email.com', password='secret' ) self.post = Post.objects.create( title='A good title', body='Nice body content', author=self.user, ) def test_string_representation(self): post = Post(title='A sample title') self.assertEqual(str(post), post.title) 152153 Chapter 6: Forms def test_get_absolute_url(self): self.assertEquals(self.post.get_absolute_url(), '/post/ /') def test_post_content(self): self.assertEqual(f'{self.post.title}', 'A good title') self.assertEqual(f'{self.post.author}', 'testuser') self.assertEqual(f'{self.post.body}', 'Nice body content') def test_post_list_view(self): response = self.client.get(reverse('home')) self.assertEqual(response.status_code, ) self.assertContains(response, 'Nice body content') self.assertTemplateUsed(response, 'home.html') def test_post_detail_view(self): response = self.client.get('/post/ /') no_response = self.client.get('/post/ self.assertEqual(response.status_code, /') ) self.assertEqual(no_response.status_code, ) self.assertContains(response, 'A good title') self.assertTemplateUsed(response, 'post_detail.html') def test_post_create_view(self): response = self.client.post(reverse('post_new'), { 'title': 'New title', 'body': 'New text', 'author': self.user, })154 Chapter 6: Forms self.assertEqual(response.status_code, ) self.assertContains(response, 'New title') self.assertContains(response, 'New text') def test_post_update_view(self): response = self.client.post(reverse('post_edit', args=' '), { 'title': 'Updated title', 'body': 'Updated text', }) self.assertEqual(response.status_code, ) def test_post_delete_view(self): response = self.client.get( reverse('post_delete', args=' ')) self.assertEqual(response.status_code, ) We expect the url of our test to be at post/ / since there\u2019s only one post and the is its primary key Django adds automatically for us. To test create view we make a new response and then ensure that the response goes through (status code 200) and contains our new title and body text. For update view we access the first post\u2013which has a pk of which is passed in as the only argument\u2013and we confirm that it results in a 302 redirect. Finally we test our delete view by confirming that if we delete a post the status code is 200 for success. There\u2019s always more tests that can be added but this at least has coverage on all our new functionality.","title":"blog/tests.py"},{"location":"7_Formularios/#conclusion","text":"In a small amount of code we\u2019ve built a blog application that allows for creating, reading, updating, and deleting blog posts. This core functionality is known by the acronym CRUD: Create-Read-Update-Delete. While there are multiple ways to achieve this same functionality\u2013we could have used function-based views or written our own class-based views\u2013we\u2019ve demonstrated how little code it takes in Django to make this happen. In the next chapter we\u2019ll add user accounts and login, logout, and signup functionality.","title":"Conclusi\u00f3n"}]}